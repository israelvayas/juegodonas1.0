<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Donut Frenzy</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Estilo general para el ambiente retro */
        body {
            font-family: 'Press Start 2P', monospace;
            background-color: #1a1a2e; /* Fondo oscuro retro */
            color: #e5e5f7; /* Texto claro */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        /* Estilo para el lienzo del juego (Canvas) */
        #gameCanvas {
            border: 4px solid #f4d03f; /* Borde amarillo de arcade (Default) */
            box-shadow: 0 0 20px rgba(244, 208, 63, 0.7), inset 0 0 10px rgba(255, 255, 255, 0.5);
            background-color: #2c3e50; /* Cielo azul oscuro pixeleado (Default) */
            cursor: none;
            /* Aplicaci√≥n robusta del renderizado pixelado */
            image-rendering: pixelated;
            image-rendering: crisp-edges; 
            /* CORRECCI√ìN PARA MOVIL */
            width: 100%;
            max-width: 400px; 
            height: auto;
            aspect-ratio: 4 / 3; 
            touch-action: none;
            transition: all 0.5s ease; /* Transici√≥n suave para cambios de escenario */
        }

        /* Estilo para los botones */
        .retro-button {
            background-color: #e74c3c;
            color: #fff;
            padding: 10px 20px;
            margin: 5px;
            border: 4px solid #c0392b;
            box-shadow: 0 5px 0 #922b21;
            transition: all 0.1s;
            text-shadow: 1px 1px 0 #000;
            font-family: 'Press Start 2P', monospace; /* Aplicar fuente retro */
        }
        .retro-button:hover {
            background-color: #c0392b;
            box-shadow: 0 2px 0 #922b21;
            transform: translateY(3px);
        }
        .retro-input {
            background-color: #3b3b54;
            color: #e5e5f7;
            border: 2px solid #f4d03f;
            padding: 8px;
            width: 100%;
            max-width: 300px;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
            font-family: 'Press Start 2P', monospace; /* Aplicar fuente retro */
            font-size: 10px;
        }

        /* Contenedor principal con efecto de pixelado y centrado */
        .game-container {
            width: 100%;
            max-width: 650px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Estilo para los Modals (Leaderboard, Info) */
        #leaderboard, #infoPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 350px;
            background-color: rgba(0, 0, 0, 0.9);
            color: #f4d03f;
            border: 4px solid #f4d03f;
            padding: 20px;
            font-size: 10px;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 50;
            font-family: 'Press Start 2P', monospace; /* Aplicar fuente retro */
        }
    </style>
</head>
<body class="p-4">
    
    <div id="infoPanel" class="hidden">
        <h3 class="info-title">GU√çA R√ÅPIDA</h3>
        <div class="mb-3">
            <h4 class="text-sm text-green-400 mb-1">‚úÖ COGE (Puntos/Power-Up)</h4>
            <div class="text-xs">
                <div class="flex items-center mb-1">üç© Dona: +10 Puntos (x<span id="guideMultiplier">1</span>)</div>
                <div class="flex items-center mb-1">‚ù§Ô∏è Coraz√≥n: +1 Vida (M√°x 6). (M√°x 3 por nivel)</div>
                <div class="flex items-center mb-1">üåü Puntos X3: Triplica el valor de las donas. (N2)</div>
                <div class="flex items-center mb-1">üòá Inmunidad Total: Invulnerabilidad a todo. (N3)</div>
                <div class="flex items-center mb-1">üåÄ Aspiradora: Cesta m√°s grande.</div>
                <div class="flex items-center mb-1">üõ°Ô∏è Escudo: Resiste 1 golpe extra.</div>
                <div class="flex items-center mb-1">üêå Lento: Ralentiza objetos.</div>
            </div>
        </div>
        <div>
            <h4 class="text-sm text-red-400 mb-1">‚ùå EVITA (¬°Da√±o!)</h4>
            <div class="text-xs">
                <div class="flex items-center mb-1">üí£ Bomba: 1 Vida Menos. (N1-4, N8)</div>
                <div class="flex items-center mb-1">üß± Ladrillo: 1 Vida Menos. (N1-4, N8)</div>
                <div class="flex items-center mb-1">üêÑ Vaca: 1 Vida Menos. (N5-7)</div>
                <div class="flex items-center mb-1">üöì Otro Carro: 1 Vida Menos. (N5-7)</div>
                <div class="flex items-center mb-1">üö¥ Ciclista: 1 Vida Menos. (N5-7)</div>
                <div class="flex items-center mb-1">üç© Dona Perdida: 1 Vida Menos.</div>
            </div>
        </div>
        <button id="closeInfoButton" class="retro-button bg-gray-600 border-gray-700 hover:bg-gray-700 text-xs mt-4 w-full">CERRAR</button>
    </div>
    
    <div id="leaderboard" class="hidden">
        <h3 class="leaderboard-title">TOP R√©cords</h3>
        <p class="text-xs text-yellow-400 mb-2">¬°Todos los jugadores con nombre de usuario o perfil completo compiten aqu√≠!</p>
        <div id="leaderboardContent">
            <p class="text-center text-xs">Cargando...</p>
        </div>
        <button id="closeLeaderboardButton" class="retro-button bg-gray-600 border-gray-700 hover:bg-gray-700 text-xs mt-4 w-full">CERRAR</button>
    </div>


    <div class="game-container text-center">
        <h1 class="text-3xl mb-4 text-yellow-300 shadow-lg" style="text-shadow: 4px 4px #e74c3c;">PIXEL DONUT FRENZY</h1>
        
        <div id="authScreen" class="p-6 bg-gray-800 border-4 border-yellow-500 rounded-lg max-w-sm mx-auto">
            <h2 class="text-2xl mb-4 text-pink-400">ACCESO</h2>
            <input type="email" id="emailInput" placeholder="EMAIL" class="retro-input mb-3" />
            <input type="password" id="passwordInput" placeholder="CONTRASE√ëA" class="retro-input mb-4" />
            <button id="loginButton" class="retro-button w-full mb-2">INICIAR SESI√ìN</button>
            <button id="registerButton" class="retro-button bg-blue-500 border-blue-700 hover:bg-blue-700 w-full mb-2">REGISTRARSE</button>
        
            <button id="anonymousLoginButton" class="retro-button bg-green-500 border-green-700 hover:bg-green-700 w-full">JUGAR COMO INVITADO</button>
            <p id="authMessage" class="mt-3 text-sm text-red-400"></p>
        </div>
        
        <div id="profileScreen" class="hidden p-6 bg-gray-800 border-4 border-yellow-500 rounded-lg max-w-sm mx-auto">
            <h2 class="text-2xl mb-4 text-pink-400">CREA TU NOMBRE DE JUGADOR</h2>
            <p class="mb-4 text-sm">Ingresa tu nombre y apellido (o solo un nombre de fantas√≠a) para competir en el Leaderboard.</p>
            <input type="text" id="nameInput" placeholder="NOMBRE" class="retro-input mb-3" />
            <input type="text" id="lastNameInput" placeholder="APELLIDO (Opcional)" class="retro-input mb-4" />
            <button id="saveProfileButton" class="retro-button bg-green-500 border-green-700 hover:bg-green-700 w-full">GUARDAR Y JUGAR</button>
            <p id="profileMessage" class="mt-3 text-sm text-red-400"></p>
        </div>

        <div id="loadingScreen" class="hidden mt-4">
            <h2 class="text-2xl text-yellow-400">CARGANDO...</h2>
            <p class="mt-2 text-sm">Preparando la m√°quina arcade.</p>
        </div>
        
        <div id="gameScreens" class="hidden">
            <div class="relative w-full" style="max-width: 400px; aspect-ratio: 4 / 3;">
                
                <div id="inGameScoreDisplay" class="absolute top-0 left-0 right-0 p-2 text-center text-xl text-yellow-300 pointer-events-none" style="text-shadow: 2px 2px #000; z-index: 10;">
                    PUNTOS: <span id="currentInGameScore">0</span>
                    <div class="flex justify-center items-center mt-1">
                        <div id="livesDisplay" class="text-red-500 text-lg mr-4">
                        </div>
                        <div id="inGamePowerUpDisplay" class="text-base text-pink-400 font-bold" style="font-size: 10px;">
                            </div>
                    </div>
                </div>
              
                <canvas id="gameCanvas" width="400" height="300"></canvas>
            
                <div id="levelTransitionScreen" class="absolute inset-0 flex flex-col items-center justify-center p-4 bg-black bg-opacity-80 hidden">
                    <h2 id="transitionMessage" class="text-4xl text-green-500 mb-6" style="text-shadow: 2px 2px #000;">NIVEL SUPERADO</h2>
                    <button id="nextLevelButton" class="retro-button text-xl hidden">CONTINUAR AL NIVEL <span id="nextLevelNumber"></span></button>
                </div>

                <div id="gameOverScreen" class="absolute inset-0 flex flex-col items-center justify-center p-4 bg-black bg-opacity-75 hidden">
                    <h2 class="text-4xl text-red-500 mb-4" style="text-shadow: 2px 2px #000;">GAME OVER</h2>
                    <button id="startButton" class="retro-button text-lg">REINTENTAR</button>
                </div>
            
                <div id="startScreen" class="absolute inset-0 flex flex-col items-center justify-center p-4 bg-black bg-opacity-75 hidden">
                    <p class="text-lg mb-4">Usa &larr; y &rarr; (o desliza el dedo) para moverte.</p>
                    <p class="text-lg mb-4 text-red-400">¬°Tienes <span id="initialLivesDisplay">3</span> vidas!</p>
                    <button id="initialStartButton" class="retro-button text-xl">EMPEZAR</button>
                </div>
            </div>
            
            <div id="statsPanel" class="mt-4 p-3 bg-gray-800 border-4 border-yellow-500 rounded-lg text-sm grid grid-cols-2 gap-2 w-full" style="font-family: 'Press Start 2P', monospace; max-width: 400px;">
                <div class="text-left">USUARIO: <span id="userDisplay" class="text-green-400">...</span></div>
                <div class="text-right">NIVEL: <span id="levelDisplay" class="text-pink-400">1</span></div>
                <div class="col-span-2 text-center text-yellow-400">MI R√âCORD: <span id="highScoreDisplay" class="text-pink-400">0</span></div>
            </div>

            <div class="mt-4 flex justify-center space-x-4 w-full" style="max-width: 400px;">
                <button id="showInfoButton" class="retro-button bg-blue-500 border-blue-700 hover:bg-blue-700 text-sm">GU√çA</button>
                <button id="showLeaderboardButton" class="retro-button bg-purple-500 border-purple-700 hover:bg-purple-700 text-sm">R√âCORDS</button>
                <button id="logoutButton" class="retro-button bg-gray-600 border-gray-700 hover:bg-gray-700 text-sm">CERRAR SESI√ìN</button>
            </div>
        </div>
    </div>

    <script type="module">
        // === CONFIGURACI√ìN GLOBAL DE FIREBASE ===
        // NOTA: Si los botones no funcionan, verifica que los m√©todos de Auth (Email/Pass y An√≥nimo)
        // est√©n ACTIVADOS en tu Consola de Firebase.
        const firebaseConfig = {
            apiKey: "AIzaSyDvAkI_aBIiezkbSEwgdmpduaGKtw4XLOs",
            authDomain: "controlceo-fdd05.firebaseapp.com",
            projectId: "controlceo-fdd05",
            storageBucket: "controlceo-fdd05.firebasestorage.app",
            messagingSenderId: "207151362101",
            appId: "1:207151362101:web:3ba86ac5680fd41e55417c"
        };
        const appId = firebaseConfig.projectId;

        // === FIREBASE IMPORTS ===
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged, updateProfile, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, collection, query, limit, onSnapshot, orderBy } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        // === INICIALIZACI√ìN DE FIREBASE ===
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        
        // Referencias a colecciones y documentos
        const getUserDocRef = (userId) => doc(db, `artifacts/${appId}/users/${userId}/data`, "game_stats");
        // Colecci√≥n p√∫blica para el Leaderboard
        const LEADERBOARD_COLLECTION = `artifacts/${appId}/public/data/leaderboard`;
        // === CONFIGURACI√ìN DEL JUEGO ===
        const CANVAS_WIDTH = 400;
        const CANVAS_HEIGHT = 300;
        const PLAYER_SIZE = 30;
        const OBJECT_SIZE = 25;
        const PLAYER_INITIAL_LIVES = 3; 
        const PLAYER_MAX_LIVES = 6;
        const INVULNERABILITY_DURATION = 5000; 
        const SHIELD_BONUS_LIFE = 1; 

        // NUEVAS CONSTANTES DE NIVEL
        const SCORE_TO_LEVEL_UP = 300;
        // MODIFICACI√ìN: Nivel 8 es el final e infinito
        const MAX_LEVEL = 8;
        const BASE_SPAWN_INTERVAL_MS = 1000;
        const BASE_GAME_SPEED = 1.5;
        const MAX_HEARTS_PER_LEVEL = 3; 
        const HEART_SPAWN_INTERVAL_MS = 15000;
        // Elementos del DOM
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const highScoreDisplay = document.getElementById('highScoreDisplay');
        const inGamePowerUpDisplay = document.getElementById('inGamePowerUpDisplay');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startButton = document.getElementById('startButton');
        const initialStartButton = document.getElementById('initialStartButton');
        const gameScreens = document.getElementById('gameScreens');
        const userDisplay = document.getElementById('userDisplay');
        const levelDisplay = document.getElementById('levelDisplay');
        const currentInGameScore = document.getElementById('currentInGameScore');
        const livesDisplay = document.getElementById('livesDisplay'); 
        const initialLivesDisplay = document.getElementById('initialLivesDisplay');
        
        const levelTransitionScreen = document.getElementById('levelTransitionScreen');
        const transitionMessage = document.getElementById('transitionMessage');
        const nextLevelButton = document.getElementById('nextLevelButton');
        const nextLevelNumber = document.getElementById('nextLevelNumber');
        
        // Elementos de autenticaci√≥n y perfil
        const authScreen = document.getElementById('authScreen');
        const emailInput = document.getElementById('emailInput');
        const passwordInput = document.getElementById('passwordInput');
        const loginButton = document.getElementById('loginButton');
        const registerButton = document.getElementById('registerButton');
        const anonymousLoginButton = document.getElementById('anonymousLoginButton');
        const logoutButton = document.getElementById('logoutButton');
        const authMessage = document.getElementById('authMessage');
        // Usuario Registrado / Invitado (UNIFICADO)
        const profileScreen = document.getElementById('profileScreen');
        const nameInput = document.getElementById('nameInput');
        const lastNameInput = document.getElementById('lastNameInput');
        const saveProfileButton = document.getElementById('saveProfileButton');
        const profileMessage = document.getElementById('profileMessage');
        // Modals
        const leaderboard = document.getElementById('leaderboard');
        const leaderboardContent = document.getElementById('leaderboardContent');
        const infoPanel = document.getElementById('infoPanel');
        const showInfoButton = document.getElementById('showInfoButton');
        const showLeaderboardButton = document.getElementById('showLeaderboardButton');
        const closeInfoButton = document.getElementById('closeInfoButton');
        const closeLeaderboardButton = document.getElementById('closeLeaderboardButton');
        // Configuraci√≥n inicial del Canvas
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
        ctx.imageSmoothingEnabled = false;

        // === ESTADO GLOBAL DEL JUEGO ===
        let score = 0;
        let highScore = 0;
        let isPlaying = false;
        let currentLevel = 1;
        let player;
        let fallingObjects = [];
        let keys = {};
        let lastSpawnTime = 0;
        let animationFrameId;
        let userId = null; 
        let userName = null;
        let scoreMultiplier = 1; 
        
        // Estado de Vidas y Power-Ups
        let playerLives = PLAYER_INITIAL_LIVES;
        let heartsSpawnedThisLevel = 0; 
        let lastHeartSpawnTime = 0; 
        let activePowerUp = null;
        let powerUpEndTime = 0;
        const POWER_UP_DURATION = 5000;
        // Estado de control de flujo
        let isPausedByTransition = false;
        // Estado para el control t√°ctil
        let touchX = null;
        // L√≥gica de Autenticaci√≥n y Leaderboard (funciones auxiliares)
        
        function setAuthMessage(message, isError = false) {
            authMessage.textContent = message;
            authMessage.className = `mt-3 text-sm ${isError ? 'text-red-400' : 'text-green-400'}`;
        }
        
        function setProfileMessage(message, isError = false, targetElement) {
            targetElement.textContent = message;
            targetElement.className = `mt-3 text-sm ${isError ? 'text-red-400' : 'text-green-400'}`;
        }

        async function loadUserHighScore() {
            if (!userId) return;
            try {
                const docRef = getUserDocRef(userId);
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const data = docSnap.data();
                    highScore = data.highScore || 0;
                } else {
                    await setDoc(docRef, { highScore: 0 });
                    highScore = 0;
                }
                playerLives = PLAYER_INITIAL_LIVES;
                updateHighScore(highScore);
            } catch (error) {
                console.error("Error al cargar el High Score:", error);
            }
        }
        
        async function saveUserStats() {
             if (!userId) return;
             try {
                 const docRef = getUserDocRef(userId);
                 const data = { 
                     highScore: highScore,
                 };
                 await setDoc(docRef, data, { merge: true });
             } catch (error) {
                 console.error("Error al guardar High Score personal:", error);
             }
        }

        function loadUserName() {
            const user = auth.currentUser;
            if (user) {
                if (user.displayName) {
                    userName = user.displayName;
                } else {
                    return false; // Forzar a ir a profileScreen si no hay display name
                }
                
                // Mostrar el display name, a√±adiendo "Invitado" si es an√≥nimo.
                const userPrefix = user.isAnonymous ? 'Invitado/' : '';
                userDisplay.textContent = userPrefix + userName;
                return true;
            }
            return false;
        }
        
        async function savePublicRecord(score) {
            // Se asegura que se utilice el √∫ltimo 'userName' cargado.
            if (!userId || !userName || score <= 0) {
                 return;
            }
            try {
                const docRef = doc(db, LEADERBOARD_COLLECTION, userId);
                const docSnap = await getDoc(docRef);
                const currentPublicScore = docSnap.exists() ? docSnap.data().score : 0;
                if (score > currentPublicScore) {
                    await setDoc(docRef, {
                        userId: userId,
                        userName: userName, // Usa el userName que se configur√≥ en loadUserName/saveProfileButton
                        score: score,
                        timestamp: Date.now()
                    }, { merge: true });
                }
            } catch (error) {
                console.error("Error al guardar r√©cord p√∫blico:", error);
            }
        }
        
        // Leaderboard listener (actualiza en tiempo real)
        const q = query(collection(db, LEADERBOARD_COLLECTION), orderBy("score", "desc"), limit(10));
        onSnapshot(q, (snapshot) => {
            const records = [];
            snapshot.forEach((doc) => {
                records.push(doc.data());
            });
            renderLeaderboard(records); 
        }, (error) => {
            console.error("Error al escuchar el Leaderboard:", error);
            leaderboardContent.innerHTML = '<p class="text-center text-xs text-red-400">Error al cargar la clasificaci√≥n.</p>';
        });
        function renderLeaderboard(records) {
            leaderboardContent.innerHTML = '';
            if (records.length === 0) {
                 leaderboardContent.innerHTML = '<p class="text-center text-xs">S√© el primero en el Leaderboard!</p>';
                return;
            }
            
            records.forEach((record, index) => {
                const isCurrentUser = record.userId === userId;
                const item = document.createElement('div');
                item.className = 'flex justify-between items-center py-1 border-b border-gray-700 last:border-b-0';
                
                
                const name = record.userName.length > 20 ? record.userName.substring(0, 19) + '...' : record.userName;

                const nameClass = isCurrentUser ? 'text-pink-400 font-bold' : '';

                item.innerHTML = `
                    <span class="${nameClass}">${index + 1}. ${name}</span>
                    <span class="${nameClass}">${record.score}</span>
                `;
                leaderboardContent.appendChild(item);
            });
        }
        
        // Manejadores de Eventos de Auth
        loginButton.addEventListener('click', async () => {
            const email = emailInput.value;
            const password = passwordInput.value;
            if (!email || !password) {
                setAuthMessage("Ingresa email y contrase√±a.", true);
                return;
            }
            setAuthMessage("Iniciando sesi√≥n...");
            try {
                await signInWithEmailAndPassword(auth, email, password);
                setAuthMessage("");
            } catch (error) {
                // Mejora: Mostrar c√≥digo de error de Firebase
                setAuthMessage("Error de sesi√≥n: " + (error.message.includes('user-not-found') ? 'Usuario no encontrado' : 'Credenciales inv√°lidas') + ` (C√≥digo: ${error.code})`, true);
            }
        });
        registerButton.addEventListener('click', async () => {
            const email = emailInput.value;
            const password = passwordInput.value;
            if (password.length < 6) {
                setAuthMessage("La contrase√±a debe tener al menos 6 caracteres.", true);
                return;
            }
            setAuthMessage("Registrando usuario...");
            try {
                await createUserWithEmailAndPassword(auth, email, password);
            } catch (error) {
                // Mejora: Mostrar c√≥digo de error de Firebase
                setAuthMessage("Error de registro: " + (error.message.includes('email-already-in-use') ? 'El email ya est√° registrado' : 'Error desconocido') + ` (C√≥digo: ${error.code})`, true);
            }
        });
        anonymousLoginButton.addEventListener('click', async () => {
            setAuthMessage("Iniciando sesi√≥n como invitado...");
            try {
                await signInAnonymously(auth); 
            } catch (error) {
                // Mejora: Mostrar c√≥digo de error de Firebase
                setAuthMessage("Error al iniciar como invitado. Verifica que la Autenticaci√≥n An√≥nima est√© habilitada en la consola de Firebase." + ` (C√≥digo: ${error.code})`, true);
            }
        });
        saveProfileButton.addEventListener('click', async () => { 
             const name = nameInput.value.trim();
             const lastName = lastNameInput.value.trim();
             // Permitir solo el nombre si el apellido est√° vac√≠o
             const displayName = (name + (lastName ? " " + lastName : "")).trim(); 
            
            
             if (displayName.length < 3) {
                 setProfileMessage("Por favor, ingresa tu nombre de jugador (m√≠nimo 3 caracteres).", true, profileMessage);
                 return;
             }

             try {
                const user = auth.currentUser;
                 
                 await updateProfile(user, { displayName: displayName });
                
                 // Recargar el nombre despu√©s de guardar
                 loadUserName(); 

                 profileScreen.classList.add('hidden');
                 gameScreens.classList.remove('hidden');
                 startScreen.classList.remove('hidden');
                
             } catch (error) {
               
                setProfileMessage("Error al guardar perfil. Intenta de nuevo.", true, profileMessage);
             }
        });
        
        // Funci√≥n de cierre de sesi√≥n
        logoutButton.addEventListener('click', async () => {
            try {
                await signOut(auth);
            } catch (error) {
                console.error("Error al cerrar sesi√≥n:", error);
            }
        });
        
        // Listener de estado de autenticaci√≥n (CR√çTICO)
        onAuthStateChanged(auth, (user) => {
            loadingScreen.classList.add('hidden');
            infoPanel.classList.add('hidden');
            leaderboard.classList.add('hidden');
            
            if (user) {
                userId = user.uid;
                authScreen.classList.add('hidden');
                
                // Carga el high score y resetea las vidas a 3
                loadUserHighScore().then(() => {
                    // Si ya tiene nombre de display
                    if (loadUserName()) { 
                        profileScreen.classList.add('hidden');
                        gameScreens.classList.remove('hidden');
                        startScreen.classList.remove('hidden');
                        initialLivesDisplay.textContent = PLAYER_INITIAL_LIVES; 
                        setAuthMessage("");
                    } else {
                        // Si no tiene nombre (an√≥nimo o registrado), va a profileScreen
                        profileScreen.classList.remove('hidden');
                        gameScreens.classList.add('hidden');
                    }
                });
            } else {
                // Usuario desconectado
                gameScreens.classList.add('hidden');
                profileScreen.classList.add('hidden');
                authScreen.classList.remove('hidden');
                userId = null;
                userName = null;
                highScore = 0;
                playerLives = PLAYER_INITIAL_LIVES; // Resetear vidas
                initialLivesDisplay.textContent = playerLives;
                updateHighScore(0);
                setAuthMessage("Por favor, inicia sesi√≥n o juega como invitado.", true);
            }
        });
        // === CONFIGURACI√ìN DE AUDIO (TONE.JS) ===
        const synth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "square" }, envelope: { release: 0.1 } }).toDestination();
        const noise = new Tone.NoiseSynth({ noise: { type: "white" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.05 } }).toDestination();
        const metal = new Tone.MetalSynth().toDestination();

        function playCollectSound() { synth.triggerAttackRelease(["C5", "G5"], "16n"); }
        function playHitSound() { noise.triggerAttackRelease("8n", Tone.now(), 0.5); metal.triggerAttackRelease("4n", Tone.now() + 0.1, 0.5); }
        function playPowerUpSound() { synth.triggerAttackRelease(["C6", "E6", "G6", "C7"], "16n"); }
        function playShieldBlockSound() { synth.triggerAttackRelease(["D3", "A3"], "8n", Tone.now(), 0.8); }
        function playGameOverSound() { synth.triggerAttackRelease(["C3", "G#2", "F2"], "2n"); noise.triggerAttackRelease("2n", Tone.now(), 1.0); }


        // === IMPLEMENTACI√ìN DE POWER-UPS ===
        const powerUps = {
            'vacuum': {
                symbol: 'üåÄ',
                color: '#3498db',
                name: 'ASPIRADORA DE DONAS', 
                effect: () => { player.width = PLAYER_SIZE * 2; },
                cleanup: () => { player.width = PLAYER_SIZE; }
            },
            'shield': {
                symbol: 'üõ°Ô∏è',
                color: '#2ecc71',
                name: 'ESCUDO DE IMPACTO', 
                effect: () => { player.lives += SHIELD_BONUS_LIFE; }, 
                cleanup: () => { 
                    player.lives = playerLives;
                } 
            },
            'slow': {
                symbol: 'üêå',
                color: '#f1c40f',
                name: 'TIEMPO LENTO', 
                effect: () => {}, 
                cleanup: () => {}
            },
            'x3': {
                symbol: 'üåü',
                color: '#ff5722',
                name: 'PUNTOS TRIPLES', 
                effect: () => { scoreMultiplier = 3; },
                cleanup: () => { scoreMultiplier = 1; }
            },
            'invulnerable': { // NUEVO: INMUNIDAD TOTAL
                symbol: 'üòá',
                color: '#f39c12',
                name: 'INMUNIDAD TOTAL',
                effect: () => { 
                    player.isInvulnerable = true;
                    player.invulnerabilityEndTime = Date.now() + POWER_UP_DURATION;
                },
                cleanup: () => { 
                    player.isInvulnerable = false;
                    player.invulnerabilityEndTime = 0;
                }
            }
        };
        const objectSymbols = {
            'donut': 'üç©',
            'bomb': 'üí£',
            'stone': 'üß±',
            'heart': '‚ù§Ô∏è', 
            'cow': 'üêÑ', 
            'otherCar': 'üöì', // Nuevo obst√°culo
            'biker': 'üö¥', // Nuevo obst√°culo
        };
        // Lista de todos los objetos peligrosos (para colisi√≥n)
        const allObstacles = ['bomb', 'stone', 'cow', 'otherCar', 'biker'];
        // Funci√≥n para actualizar los corazones en el HTML
        function updateLivesDisplay() {
            const hasShield = activePowerUp === 'shield' && player.lives > playerLives;
            const extraIndicator = hasShield ? ' üõ°Ô∏è' : '';
            
            livesDisplay.innerHTML = '‚ù§Ô∏è '.repeat(playerLives) + extraIndicator;
        }

        // === CLASES DE ENTIDADES ===

        class Player {
            constructor(x, y, size, initialLives) {
                this.x = x;
                this.y = y;
                this.width = size;
                this.height = size;
                this.speed = 4;
                this.lives = initialLives;
                // isInvulnerable se usa para: a) Power-up Inmunidad Total, b) Post-hit grace period
                this.isInvulnerable = false;
                this.invulnerabilityEndTime = 0; 
            }

            draw() {
                // El efecto de parpadeo de invulnerabilidad
                const isFlashing = this.isInvulnerable && Date.now() < this.invulnerabilityEndTime && Math.floor(Date.now() / 100) % 2 === 0;
                // Si la invulnerabilidad es activa (por power-up o post-hit) y est√° en el ciclo de parpadeo, no dibujar.
                if (isFlashing) {
                    return;
                }

                // Usar la fuente pixelada para el renderizado del canvas
                ctx.font = `${this.height}px 'Press Start 2P', monospace`;
                ctx.textAlign = 'center';
                
                // MODIFICACI√ìN: Personaje seg√∫n el nivel
                let emoji = 'üõí'; // N1-N4 (Arcade)
                if (currentLevel >= 5 && currentLevel <= 7) {
                    emoji = 'üöó'; // Coche para Nivel 5-7 (Carretera)
                } else if (currentLevel >= 8) {
                    emoji = 'üòÄ'; // Cara/Emoji vivaracho para Nivel 8 (Casa)
                }

                ctx.fillText(emoji, this.x + this.width / 2, this.y + this.height * 0.9);
                // Dibujar el efecto del escudo 
                if (this.lives > playerLives && activePowerUp === 'shield') {
                    ctx.fillStyle = 'rgba(46, 204, 113, 0.4)';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    ctx.fillStyle = '#2ecc71';
                    ctx.fillRect(this.x, this.y, this.width, 3);
                    ctx.fillRect(this.x, this.y + this.height - 3, this.width, 3);
                }
            }

            update() {
                // Control de movimiento 
                if (keys['ArrowLeft'] || keys['a']) {
                    this.x -= this.speed;
                }
                if (keys['ArrowRight'] || keys['d']) {
                    this.x += this.speed;
                }
                if (touchX !== null) {
                    const targetX = touchX - this.width / 2;
                    const dx = targetX - this.x;
                    if (Math.abs(dx) > this.speed) {
                        this.x += Math.sign(dx) * this.speed;
                    } else {
                        this.x = targetX;
                    }
                }

                // Si la invulnerabilidad actual *no* es por power-up, chequear el tiempo de gracia post-hit.
                if (activePowerUp !== 'invulnerable' && this.isInvulnerable && Date.now() > this.invulnerabilityEndTime) {
                    this.isInvulnerable = false;
                }

                // Si la invulnerabilidad *es* por power-up, se gestiona en checkPowerUpExpiry.
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > CANVAS_WIDTH) this.x = CANVAS_WIDTH - this.width;
            }
        }

        class FallingObject {
            constructor(x, y, type, speed) {
                this.x = x;
                this.y = y;
                this.width = OBJECT_SIZE;
                this.height = OBJECT_SIZE;
                this.type = type;
                this.speed = speed;
            }

            getSymbol() {
                if (powerUps[this.type]) {
                    return powerUps[this.type].symbol;
                }
                return objectSymbols[this.type] || '‚ùì';
            }

            draw() {
                // Usar la fuente pixelada para el renderizado del canvas
                ctx.font = `${this.height}px 'Press Start 2P', monospace`;
                ctx.textAlign = 'center';

                // Distinci√≥n visual: Power-Ups tienen fondo de color.
                if (powerUps[this.type]) {
                    ctx.fillStyle = powerUps[this.type].color;
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
                // Dibuja un aura para los corazones
                if (this.type === 'heart') {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }

                ctx.fillText(this.getSymbol(), this.x + this.width / 2, this.y + this.height * 0.9);
            }

            update() {
                let currentSpeed = this.speed;
                // L√ìGICA DE LENTITUD
                if (activePowerUp === 'slow' && Date.now() < powerUpEndTime) {
                    currentSpeed *= 0.5;
                }

                this.y += currentSpeed;
                if (activePowerUp === 'vacuum' && Date.now() < powerUpEndTime && this.type === 'donut') {
                    const playerCenterX = player.x + player.width / 2;
                    const objectCenterX = this.x + this.width / 2;
                    const diffX = playerCenterX - objectCenterX;

                    this.x += Math.sign(diffX) * 2;
                }
            }
        }

        // === L√ìGICA DEL JUEGO ===

        // MODIFICACI√ìN: La dificultad del nivel 8 aumenta con el puntaje
        function getDifficultyMultiplier(level) {
            if (level === MAX_LEVEL) { // Nivel 8 (Infinito)
                // Base de dificultad del Nivel 8
                const baseDifficulty = 1 + (MAX_LEVEL - 1) * 0.15; // 2.05
                // Aumento progresivo cada 500 puntos (simula un nivel virtual)
                const scoreIncrease = Math.floor(score / 500) * 0.05; 
                return baseDifficulty + scoreIncrease;
            }
            return 1 + (level - 1) * 0.15;
        }

        function startNewLevel(level) {
            if (!userId || !userName) {
                // Forzar la creaci√≥n de nombre si a√∫n no lo tiene
                profileScreen.classList.remove('hidden');
                gameScreens.classList.add('hidden');
                return;
            }
            if (Tone.context.state !== 'running') {
                Tone.start();
            }

            currentLevel = level;
            levelDisplay.textContent = currentLevel;
            // CORRECCI√ìN SOLICITADA: Score solo se reinicia en Nivel 1 (inicio de partida)
            if (level === 1) { 
                score = 0;
                playerLives = PLAYER_INITIAL_LIVES; 
                updateHighScore(highScore);
            }
            
            isPlaying = true;
            // Reinicia jugador, objetos y estado
            // Nota: player.lives siempre se ajusta a playerLives (la vida actual del juego)
            player = new Player(CANVAS_WIDTH / 2 - PLAYER_SIZE / 2, CANVAS_HEIGHT - PLAYER_SIZE - 10, PLAYER_SIZE, playerLives);
            fallingObjects = [];
            lastSpawnTime = 0;
            
            // Resetear contadores de nivel
            heartsSpawnedThisLevel = 0;
            lastHeartSpawnTime = 0; 
            
            // Limpiar Power-Up si exist√≠a
            if (activePowerUp) {
                powerUps[activePowerUp].cleanup();
            }
            activePowerUp = null;
            powerUpEndTime = 0;
            scoreMultiplier = 1; 
            player.isInvulnerable = false;
            touchX = null;
            
            // Limpiar Power-Up Display
            inGamePowerUpDisplay.textContent = '';
            // Actualizar display de vidas y multiplicador
            updateLivesDisplay();
            document.getElementById('guideMultiplier').textContent = scoreMultiplier;
            initialLivesDisplay.textContent = playerLives;
            
            // Oculta pantallas de men√∫
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            levelTransitionScreen.classList.add('hidden');
            
            document.getElementById('statsPanel').classList.remove('hidden');
            
            // Configuraci√≥n visual del Nivel (Arcade, Carretera o Casa)
            if (level >= 5 && level <= 7) {
                 // MODIFICACI√ìN: Escenario Carretera
                 canvas.style.borderColor = '#95a5a6'; // Gris claro/asfalto para borde (L√≠neas blancas/amarillas)
                 canvas.style.backgroundColor = '#34495e'; // Gris oscuro/Asfalto
            } else if (level === 8) {
                 // Configuraci√≥n visual del Nivel 8 (Casa, infinito)
                 canvas.style.borderColor = '#795548'; // Borde marr√≥n (Casa)
                 canvas.style.backgroundColor = '#a1887f'; // Fondo m√°s claro (Casa)
            } else {
                 // Niveles 1-4 (Arcade)
                 canvas.style.borderColor = '#f4d03f'; // Arcade
                 canvas.style.backgroundColor = '#2c3e50'; // Cielo oscuro pixeleado
            }
            canvas.style.boxShadow = '0 0 20px rgba(244, 208, 63, 0.7), inset 0 0 10px rgba(255, 255, 255, 0.5)';
            // Muestra el n√∫mero de nivel brevemente y PAUSA EL JUEGO
            if (level > 1) {
                isPausedByTransition = true;
                transitionMessage.textContent = `NIVEL ${level}`;
                nextLevelButton.classList.add('hidden');
                levelTransitionScreen.classList.remove('hidden');
                
                // Si es el nivel final, se mantiene la pantalla de transici√≥n hasta que el usuario pulse continuar
                if (level === MAX_LEVEL) {
                     transitionMessage.textContent = '¬°NIVEL FINAL (CASA) ALCANZADO!';
                     nextLevelButton.classList.remove('hidden');
                } else {
                    setTimeout(() => {
                        levelTransitionScreen.classList.add('hidden');
                        isPausedByTransition = false; 
                    }, 1500);
                }
                
            } else {
                 isPausedByTransition = false;
            }

            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            gameLoop(0);
        }

        function initGame() {
            startNewLevel(1);
        }

        function levelUp() {
            isPlaying = false;
            cancelAnimationFrame(animationFrameId);

            // Limpiar power-up activo
            if (activePowerUp) {
                powerUps[activePowerUp].cleanup();
                activePowerUp = null;
                inGamePowerUpDisplay.textContent = ''; 
            }
            scoreMultiplier = 1;
            if (currentLevel >= MAX_LEVEL) {
                // Si se llega al nivel MAX_LEVEL, se va a startNewLevel(MAX_LEVEL) y luego se reinicia a 1
                transitionMessage.textContent = '¬°NIVEL FINAL (CASA) ALCANZADO!';
                nextLevelButton.textContent = 'COMENZAR NIVEL FINAL (INFINITO)';
                nextLevelButton.onclick = () => startNewLevel(MAX_LEVEL); // Inicia el Nivel 8
                
                if (score > highScore) {
                    updateHighScore(score);
                    saveUserStats(); 
                }
                
                savePublicRecord(score); // Guardar r√©cord p√∫blico

                
            } else {
                currentLevel++;
                
                // --- MODIFICACI√ìN: MENSAJE PARA NIVEL 5 ---
                if (currentLevel === 5) {
                    transitionMessage.innerHTML = 'NIVEL 5<br><span class="text-lg text-yellow-300 mt-4 block" style="font-size: 14px; line-height: 1.5;">¬°Es hora de llevar las donas a casa! Ten cuidado con los autos, ciclistas y vacas, y sigue recolectando donas.</span>';
                    transitionMessage.classList.remove('text-green-500');
                } else {
                    transitionMessage.textContent = 'NIVEL SUPERADO';
                    // Asegurarse de que el estilo verde est√© presente para otros niveles
                    transitionMessage.classList.add('text-green-500');
                    // Limpiar el innerHTML por si acaso
                    if (transitionMessage.textContent === 'NIVEL SUPERADO') {
                         transitionMessage.innerHTML = 'NIVEL SUPERADO';
                    }
                }
                // --- FIN DE MODIFICACI√ìN ---

                nextLevelNumber.textContent = currentLevel;
                nextLevelButton.textContent = `CONTINUAR AL NIVEL ${currentLevel}`;
                nextLevelButton.onclick = () => startNewLevel(currentLevel);
            }
            
            levelTransitionScreen.classList.remove('hidden');
            nextLevelButton.classList.remove('hidden');
        }


        function updateHighScore(newScore) {
            if (newScore > highScore) {
                highScore = newScore;
            }
            highScoreDisplay.textContent = highScore;
        }

        function spawnObject(currentTime) {
            const levelDifficulty = getDifficultyMultiplier(currentLevel);
            const timeElapsed = currentTime - lastSpawnTime;
            const scoreMultiplierForDifficulty = 1 + Math.floor(score / 150) * 0.1;
            // El spawn interval se basa en la dificultad creciente (Score) y la dificultad del Nivel (Level)
            const spawnInterval = BASE_SPAWN_INTERVAL_MS / (levelDifficulty * scoreMultiplierForDifficulty); 
            
            // L√≥gica de spawn de Coraz√≥n (intervalo y l√≠mite)
            if (playerLives < PLAYER_MAX_LIVES && heartsSpawnedThisLevel < MAX_HEARTS_PER_LEVEL && currentTime - lastHeartSpawnTime > HEART_SPAWN_INTERVAL_MS) {
                const x = Math.random() * (CANVAS_WIDTH - OBJECT_SIZE);
                const speed = BASE_GAME_SPEED * levelDifficulty * scoreMultiplierForDifficulty * 0.9;
                
                fallingObjects.push(new FallingObject(x, -OBJECT_SIZE, 'heart', speed));
                heartsSpawnedThisLevel++;
                lastHeartSpawnTime = currentTime; // Actualiza el tiempo con el valor de rAF
                return;
            }


            if (timeElapsed > spawnInterval) {
                lastSpawnTime = currentTime;
                const x = Math.random() * (CANVAS_WIDTH - OBJECT_SIZE);
                const speed = BASE_GAME_SPEED * levelDifficulty * scoreMultiplierForDifficulty * 0.9;
                let objectType = 'donut';
                const rand = Math.random();

                let powerUpChance = currentLevel >= 2 ? 0.15 : 0.08;
                // === L√ìGICA DE SPAWN POR NIVEL ===
                if (currentLevel < 8) {
                    // NIVELES 1-7: L√≥gica Progresiva
                    if (score > 100) {
                        // 1. Power-Ups (Max 15% chance)
                        if (rand < powerUpChance) { 
                            let availablePowerUps = ['vacuum', 'shield', 'slow'];
                            if (currentLevel >= 2) {
                                availablePowerUps.push('x3');
                            }
                            if (currentLevel >= 3) {
                                availablePowerUps.push('invulnerable'); 
                            }
                            
                            objectType = availablePowerUps[Math.floor(Math.random() * availablePowerUps.length)];
                        } 
                        // 2. Peligros: Corregido para garantizar donas
                        else {
                            // Max Probabilidad No-Dona (80% para asegurar 20% de donas MINIMO)
                            const MAX_NON_DONUT_CHANCE = 0.80; 
                            
                            // Espacio para Peligros: M√°ximo que puede ocupar el peligro (ej. 0.80 - 0.15 = 0.65)
                            const maxDangerFill = MAX_NON_DONUT_CHANCE - powerUpChance; 
                            
                            // Aumento del peligro con el score. (Llega al m√°ximo a los 4000 puntos)
                            let scoreDangerIncrease = Math.min(maxDangerFill, maxDangerFill * (score / 4000));
                            
                            // Umbral de Peligro (si rand es menor que esto, cae un peligro)
                            let dangerThreshold = powerUpChance + scoreDangerIncrease;

                            if (rand < dangerThreshold) {
                                let dangerTypes = ['bomb', 'stone'];
                                if (currentLevel >= 5 && currentLevel <= 7) { 
                                    dangerTypes = ['cow', 'otherCar', 'biker']; 
                                } else if (currentLevel < 5) {
                                    dangerTypes = ['bomb', 'stone'];
                                }
                                
                                objectType = dangerTypes[Math.floor(Math.random() * dangerTypes.length)];
                            }
                            // else, objectType permanece 'donut'
                        }
                    }
                } 
                // === L√ìGICA DE SPAWN PARA NIVEL 8 (FINAL) ===
                else {
                    if (score > 100) {
                        // Power-Ups de L1-L4
                        let availablePowerUpsL4 = ['vacuum', 'shield', 'slow', 'x3', 'invulnerable'];
                        
                        // 1. Power-Ups
                        if (rand < powerUpChance) { 
                            objectType = availablePowerUpsL4[Math.floor(Math.random() * availablePowerUpsL4.length)];
                        } 
                        // 2. Peligros: Corregido para garantizar donas
                        else {
                            // Max Probabilidad No-Dona (80% para asegurar 20% de donas MINIMO)
                            const MAX_NON_DONUT_CHANCE = 0.80; 
                            const maxDangerFill = MAX_NON_DONUT_CHANCE - powerUpChance; 
                            
                            // Aumento del peligro con el score. (Usamos un score m√°s alto para que el nivel sea m√°s largo)
                            let scoreDangerIncrease = Math.min(maxDangerFill, maxDangerFill * (score / 6000));
                            
                            let dangerThreshold = powerUpChance + scoreDangerIncrease;

                            if (rand < dangerThreshold) {
                                let dangerTypesL8 = ['bomb', 'stone'];
                                objectType = dangerTypesL8[Math.floor(Math.random() * dangerTypesL8.length)];
                            }
                             // else, objectType permanece 'donut'
                        }
                    }
                }

                fallingObjects.push(new FallingObject(x, -OBJECT_SIZE, objectType, speed));
            }
        }

        function checkCollisions(object, index) {
            
            // Si el power-up de inmunidad total est√° activo, ignorar colisiones de peligro y donas perdidas.
            const isFullyInvulnerable = activePowerUp === 'invulnerable' && Date.now() < powerUpEndTime;
            // Objeto fuera de la pantalla (p√©rdida)
            if (object.y > CANVAS_HEIGHT) {
                // Si es una dona y se pierde
                if (object.type === 'donut') {
                    
                    if (isFullyInvulnerable) { // Inmunidad Total: No pierdes vida.
                        fallingObjects.splice(index, 1); 
                        return true;
                    }
                    
                    if (player.isInvulnerable) { // Invulnerabilidad post-hit: No pierdes vida.
                        fallingObjects.splice(index, 1); 
                        return true;
                    }

                    player.lives--;
                    playerLives = Math.max(0, playerLives - 1); 
                    updateLivesDisplay();
                    playHitSound();
                    
                    if (player.lives <= 0) {
                         gameOver();
                    } else {
                        player.isInvulnerable = true;
                        player.invulnerabilityEndTime = Date.now() + INVULNERABILITY_DURATION; 
                        player.x = CANVAS_WIDTH / 2 - player.width / 2;
                        if (activePowerUp === 'shield') {
                            powerUps['shield'].cleanup();
                            activePowerUp = null;
                            inGamePowerUpDisplay.textContent = ''; 
                        }
                    }
                    fallingObjects.splice(index, 1);
                    return true;
                }
                
                fallingObjects.splice(index, 1);
                return true;
            }
            
            // Colisi√≥n con el jugador
            if (
                object.x < player.x + player.width &&
                object.x + object.width > player.x &&
                object.y < player.y + player.height &&
                object.y + object.height > player.y
            ) {
                handleHit(object, index, isFullyInvulnerable);
                return true;
            }


            return false;
        }

        function handleHit(object, index, isFullyInvulnerable) {
            fallingObjects.splice(index, 1);
            if (object.type === 'donut') {
                score += 10 * scoreMultiplier;
                updateHighScore(score);
                playCollectSound();
            } else if (object.type === 'heart') {
                // Evitar que el coraz√≥n active la invulnerabilidad al recogerlo.
                if (playerLives < PLAYER_MAX_LIVES) {
                    playerLives++;
                    player.lives = playerLives; 
                    
                    if(activePowerUp === 'shield') {
                        player.lives += SHIELD_BONUS_LIFE;
                    }

                    updateLivesDisplay();
                    playPowerUpSound();
                } else {
                    // Si ya tiene max vidas, da puntos de bonificaci√≥n
                    score += 20 * scoreMultiplier;
                    updateHighScore(score);
                    playCollectSound(); 
                }
            } else if (allObstacles.includes(object.type)) { // Colisi√≥n con cualquier obst√°culo
                
                if (isFullyInvulnerable) {
                    playShieldBlockSound(); // Feedback de que el power-up bloque√≥ el golpe
                    return;
                }
                
                if (player.isInvulnerable) { // Invulnerabilidad post-hit
                    return;
                }
                
                if (activePowerUp === 'shield' && player.lives > playerLives) {
                    
                    // Remueve el efecto del escudo (1 vida extra)
                    powerUps['shield'].cleanup();
                    activePowerUp = null;
                    powerUpEndTime = 0;
                    
                    playShieldBlockSound(); // Restaura el estilo visual del canvas al normal del nivel
                    const originalBorderColor = currentLevel >= 5 && currentLevel <= 7 ?
                    '#95a5a6' : (currentLevel === 8 ? '#795548' : '#f4d03f');
                    canvas.style.borderColor = originalBorderColor; 

                    inGamePowerUpDisplay.textContent = ''; 
                    updateLivesDisplay();
                } else {
                    // Pierde vida
                    player.lives--;
                    playerLives = Math.max(0, playerLives - 1); 
                    playHitSound();
                    updateLivesDisplay(); 

                    if (player.lives <= 0) {
                        gameOver();
                    } else {
                        // Solo activar invulnerabilidad al perder vida por golpe de peligro
                        player.isInvulnerable = true;
                        player.invulnerabilityEndTime = Date.now() + INVULNERABILITY_DURATION; 
                        player.x = CANVAS_WIDTH / 2 - player.width / 2;
                    }
                }
            } else if (powerUps[object.type]) {
                activatePowerUp(object.type);
            }
        }

        function activatePowerUp(type) {
            if (activePowerUp && activePowerUp !== type) {
                powerUps[activePowerUp].cleanup();
            }

            activePowerUp = type;
            powerUpEndTime = Date.now() + POWER_UP_DURATION;
            powerUps[activePowerUp].effect();
            
            const puName = powerUps[activePowerUp].name;
            inGamePowerUpDisplay.textContent = puName; 

            canvas.style.boxShadow = `0 0 30px 10px ${powerUps[activePowerUp].color}, inset 0 0 15px rgba(255, 255, 255, 0.7)`;
            playPowerUpSound();
            
            document.getElementById('guideMultiplier').textContent = scoreMultiplier;
            updateLivesDisplay(); 
        }

        function checkPowerUpExpiry() {
            if (activePowerUp && Date.now() > powerUpEndTime) {
                powerUps[activePowerUp].cleanup();
                activePowerUp = null;
                
                // LIMPIAR DISPLAY
                inGamePowerUpDisplay.textContent = '';
                // Restaurar sombra del canvas
                canvas.style.boxShadow = '0 0 20px rgba(244, 208, 63, 0.7), inset 0 0 10px rgba(255, 255, 255, 0.5)';
                scoreMultiplier = 1;
                document.getElementById('guideMultiplier').textContent = scoreMultiplier;
                updateLivesDisplay(); 
            }
        }

        function gameOver() {
            isPlaying = false;
            cancelAnimationFrame(animationFrameId);

            playGameOverSound();

            if (score > highScore) {
                updateHighScore(score);
            }
            // Guardar high score
            saveUserStats();
            // Guardar r√©cord p√∫blico para todos los jugadores con nombre
            savePublicRecord(score);
            gameOverScreen.classList.remove('hidden');
            if (activePowerUp) {
                powerUps[activePowerUp].cleanup();
                activePowerUp = null;
            }
            
            // LIMPIAR DISPLAY
            inGamePowerUpDisplay.textContent = '';
            scoreMultiplier = 1; 
            document.getElementById('guideMultiplier').textContent = scoreMultiplier;

            // Restaurar estilo de Canvas a Default Arcade
            canvas.style.borderColor = '#f4d03f';
            canvas.style.backgroundColor = '#2c3e50';
            canvas.style.boxShadow = '0 0 20px rgba(244, 208, 63, 0.7), inset 0 0 10px rgba(255, 255, 255, 0.5)';
        }

        function drawGame() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            // Background color se actualiza en startNewLevel (L8 Casa, L5-7 Carretera, otros Arcade)
            ctx.fillStyle = canvas.style.backgroundColor || '#2c3e50'; 
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Dibujar l√≠neas de la carretera (solo en niveles 5-7)
            if (currentLevel >= 5 && currentLevel <= 7) {
                ctx.fillStyle = '#f1c40f'; // Amarillo para las l√≠neas
                const lineGap = 40;
                const lineWidth = 5;
                const lineHeight = 15;
                const lineOffset = (Date.now() / 150) % (lineGap + lineHeight);
                for (let i = -1; i < CANVAS_HEIGHT / (lineGap + lineHeight) + 2; i++) {
                    const y = i * (lineGap + lineHeight) + lineOffset;
                    ctx.fillRect(CANVAS_WIDTH / 2 - lineWidth / 2, y, lineWidth, lineHeight);
                }
            }


            // Se usa la fuente retro en los m√©todos draw de Player y FallingObject
            for (let i = 0; i < fallingObjects.length; i++) {
                fallingObjects[i].draw();
            }

            player.draw();

            currentInGameScore.textContent = score;

            highScoreDisplay.textContent = highScore;
            
            // Muestra un nivel virtual creciente si estamos en el nivel infinito
            if (currentLevel === MAX_LEVEL) {
                 levelDisplay.textContent = `${currentLevel} (+${Math.floor(score / 500)})`;
            } else {
                 levelDisplay.textContent = currentLevel;
            }

            if (activePowerUp && Date.now() < powerUpEndTime) {
                const elapsed = Date.now() - (powerUpEndTime - POWER_UP_DURATION);
                const percentage = 1 - (elapsed / POWER_UP_DURATION);
                const barWidth = CANVAS_WIDTH * percentage;

                ctx.fillStyle = powerUps[activePowerUp].color;
                ctx.fillRect(0, 0, barWidth, 5);
            }
        }

        // === BUCLE PRINCIPAL DEL JUEGO ===

        function gameLoop(currentTime) {
            if (!isPlaying) return;
            if (lastHeartSpawnTime === 0) {
                lastHeartSpawnTime = currentTime;
            }
            
            // Chequeo de Nivel: El nivel 8 no hace LevelUp. Solo se sube hasta el Nivel 7
            if (currentLevel < MAX_LEVEL && score >= currentLevel * SCORE_TO_LEVEL_UP) { 
                levelUp();
                return;
            }
            
            player.update();
            // VERIFICACI√ìN DE PAUSA
            if (!isPausedByTransition) {
                spawnObject(currentTime);
                checkPowerUpExpiry();

                for (let i = fallingObjects.length - 1; i >= 0; i--) {
                    fallingObjects[i].update();
                    checkCollisions(fallingObjects[i], i);
                }
            } else {
                 checkPowerUpExpiry();
            }


            drawGame();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // === EVENTOS DEL JUEGO (TECLADO Y T√ÅCTIL) ===

        initialStartButton.addEventListener('click', initGame);
        startButton.addEventListener('click', initGame);
        // Modificado para que si se est√° en la pantalla de transici√≥n de Nivel 8, el bot√≥n contin√∫e al Nivel 8
        nextLevelButton.addEventListener('click', () => {
             isPausedByTransition = false; 
             levelTransitionScreen.classList.add('hidden');
             // Si el nivel actual es el 8, simplemente reinicia el gameLoop en el nivel 8
             if (currentLevel === MAX_LEVEL) {
                 startNewLevel(currentLevel);
             } else {
                 startNewLevel(currentLevel);
             }
        });
        // Control por teclado
        document.addEventListener('keydown', (e) => {
            if (!isPlaying && (e.key === 'Enter' || e.key === ' ') && (startScreen.classList.contains('hidden') === false || gameOverScreen.classList.contains('hidden') === false || levelTransitionScreen.classList.contains('hidden') === false)) {
                
                if(!levelTransitionScreen.classList.contains('hidden') && currentLevel >= MAX_LEVEL) {
                    nextLevelButton.click();
                } else {
                    initGame();
                }
                return;
            }

            
            if (isPlaying) {
                keys[e.key] = true;
            }
        });
        document.addEventListener('keyup', (e) => {
            if (isPlaying) {
                keys[e.key] = false;
            }
        });
        // --- Control T√°ctil --- 
        function getTouchX(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.touches[0].clientX - rect.left;
            return (x / rect.width) * CANVAS_WIDTH;
        }

        canvas.addEventListener('touchstart', (e) => {
            if (isPlaying) {
                touchX = getTouchX(e);
            }
        });
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); 
            if (isPlaying) {
                touchX = getTouchX(e);
            }
        });
        canvas.addEventListener('touchend', () => {
            // touchX se mantiene
        });
        // === EVENTOS DE UTILIDAD (Gu√≠a y Leaderboard) ===
        
        showInfoButton.addEventListener('click', () => {
             infoPanel.classList.toggle('hidden');
             leaderboard.classList.add('hidden');
        });
        closeInfoButton.addEventListener('click', () => {
             infoPanel.classList.add('hidden');
        });
        showLeaderboardButton.addEventListener('click', () => {
             leaderboard.classList.toggle('hidden');
             infoPanel.classList.add('hidden');
        });
        closeLeaderboardButton.addEventListener('click', () => {
             leaderboard.classList.add('hidden');
        });
        </script>
</body>
</html>