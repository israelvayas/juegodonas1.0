<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Donut Frenzy</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Estilo general para el ambiente retro */
        body {
            font-family: 'Press Start 2P', monospace;
            background-color: #1a1a2e; /* Fondo oscuro retro */
            color: #e5e5f7; /* Texto claro */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        /* Estilo para el lienzo del juego (Canvas) */
        #gameCanvas {
            border: 4px solid #f4d03f; /* Borde amarillo de arcade */
            box-shadow: 0 0 20px rgba(244, 208, 63, 0.7), inset 0 0 10px rgba(255, 255, 255, 0.5);
            background-color: #2c3e50; /* Cielo azul oscuro pixeleado */
            cursor: none;
            /* Aplicaci√≥n robusta del renderizado pixelado */
            image-rendering: pixelated; 
            image-rendering: crisp-edges; 
            /* CORRECCI√ìN PARA MOVIL */
            width: 100%; 
            max-width: 400px; 
            height: auto;
            aspect-ratio: 4 / 3; 
            touch-action: none;
        }

        /* Estilo para los botones */
        .retro-button {
            background-color: #e74c3c;
            color: #fff;
            padding: 10px 20px;
            margin: 5px;
            border: 4px solid #c0392b;
            box-shadow: 0 5px 0 #922b21;
            transition: all 0.1s;
            text-shadow: 1px 1px 0 #000;
            font-family: 'Press Start 2P', monospace; /* Aplicar fuente retro */
        }
        .retro-button:hover {
            background-color: #c0392b;
            box-shadow: 0 2px 0 #922b21;
            transform: translateY(3px);
        }
        .retro-input {
            background-color: #3b3b54;
            color: #e5e5f7;
            border: 2px solid #f4d03f;
            padding: 8px;
            width: 100%;
            max-width: 300px;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
            font-family: 'Press Start 2P', monospace; /* Aplicar fuente retro */
            font-size: 10px;
        }

        /* Contenedor principal con efecto de pixelado y centrado */
        .game-container {
            width: 100%;
            max-width: 650px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Estilo para los Modals (Leaderboard, Info) */
        #leaderboard, #infoPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 350px;
            background-color: rgba(0, 0, 0, 0.9);
            color: #f4d03f;
            border: 4px solid #f4d03f;
            padding: 20px;
            font-size: 10px;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 50;
            font-family: 'Press Start 2P', monospace; /* Aplicar fuente retro */
        }
    </style>
</head>
<body class="p-4">
    
    <div id="infoPanel" class="hidden">
        <h3 class="info-title">GU√çA R√ÅPIDA</h3>
        <div class="mb-3">
            <h4 class="text-sm text-green-400 mb-1">‚úÖ COGE (Puntos/Power-Up)</h4>
            <div class="text-xs">
                <div class="flex items-center mb-1">üç© Dona: +10 Puntos (x<span id="guideMultiplier">1</span>)</div>
                <div class="flex items-center mb-1">‚ù§Ô∏è Coraz√≥n: +1 Vida (M√°x 6). (M√°x 3 por nivel)</div>
                <div class="flex items-center mb-1">‚ö° Puntos X2: Dobla el valor de las donas. (N2)</div>
                <div class="flex items-center mb-1">üåü Puntos X3: Triplica el valor de las donas. (N2)</div>
                <div class="flex items-center mb-1">‚≠ê Inmunidad Total: No pierdes vida por nada. (N3)</div>
                <div class="flex items-center mb-1">üåÄ Aspiradora: Cesta m√°s grande.</div>
                <div class="flex items-center mb-1">üõ°Ô∏è Escudo: Resiste 1 golpe extra.</div>
                <div class="flex items-center mb-1">üêå Lento: Ralentiza objetos.</div>
            </div>
        </div>
        <div>
            <h4 class="text-sm text-red-400 mb-1">‚ùå EVITA (¬°Da√±o!)</h4>
            <div class="text-xs">
                <div class="flex items-center mb-1">üí£ Bomba: 1 Vida Menos.</div>
                <div class="flex items-center mb-1">üß± Ladrillo: 1 Vida Menos.</div>
                <div class="flex items-center mb-1">üç© Dona Perdida: 1 Vida Menos.</div>
            </div>
        </div>
        <button id="closeInfoButton" class="retro-button bg-gray-600 border-gray-700 hover:bg-gray-700 text-xs mt-4 w-full">CERRAR</button>
    </div>
    
    <div id="leaderboard" class="hidden">
        <h3 class="leaderboard-title">TOP R√©cords</h3>
        <p class="text-xs text-yellow-400 mb-2">¬°Todos los jugadores con nombre de usuario o perfil completo compiten aqu√≠!</p>
        <div id="leaderboardContent">
            <p class="text-center text-xs">Cargando...</p>
        </div>
        <button id="closeLeaderboardButton" class="retro-button bg-gray-600 border-gray-700 hover:bg-gray-700 text-xs mt-4 w-full">CERRAR</button>
    </div>


    <div class="game-container text-center">
        <h1 class="text-3xl mb-4 text-yellow-300 shadow-lg" style="text-shadow: 4px 4px #e74c3c;">PIXEL DONUT FRENZY</h1>
        
        <div id="authScreen" class="p-6 bg-gray-800 border-4 border-yellow-500 rounded-lg max-w-sm mx-auto">
            <h2 class="text-2xl mb-4 text-pink-400">ACCESO</h2>
            <input type="email" id="emailInput" placeholder="EMAIL" class="retro-input mb-3" />
            <input type="password" id="passwordInput" placeholder="CONTRASE√ëA" class="retro-input mb-4" />
            <button id="loginButton" class="retro-button w-full mb-2">INICIAR SESI√ìN</button>
            <button id="registerButton" class="retro-button bg-blue-500 border-blue-700 hover:bg-blue-700 w-full mb-2">REGISTRARSE</button>
            <button id="anonymousLoginButton" class="retro-button bg-green-500 border-green-700 hover:bg-green-700 w-full">JUGAR COMO INVITADO</button>
            <p id="authMessage" class="mt-3 text-sm text-red-400"></p>
        </div>
        
        <div id="profileScreen" class="hidden p-6 bg-gray-800 border-4 border-yellow-500 rounded-lg max-w-sm mx-auto">
            <h2 class="text-2xl mb-4 text-pink-400">CREA TU NOMBRE DE JUGADOR</h2>
            <p class="mb-4 text-sm">Ingresa tu nombre y apellido (o solo un nombre de fantas√≠a) para competir en el Leaderboard.</p>
            <input type="text" id="nameInput" placeholder="NOMBRE" class="retro-input mb-3" />
            <input type="text" id="lastNameInput" placeholder="APELLIDO (Opcional)" class="retro-input mb-4" />
            <button id="saveProfileButton" class="retro-button bg-green-500 border-green-700 hover:bg-green-700 w-full">GUARDAR Y JUGAR</button>
            <p id="profileMessage" class="mt-3 text-sm text-red-400"></p>
        </div>

        <div id="loadingScreen" class="hidden mt-4">
            <h2 class="text-2xl text-yellow-400">CARGANDO...</h2>
            <p class="mt-2 text-sm">Preparando la m√°quina arcade.</p>
        </div>
        
        <div id="gameScreens" class="hidden">
            <div class="relative w-full" style="max-width: 400px; aspect-ratio: 4 / 3;">
                
                <div id="inGameScoreDisplay" class="absolute top-0 left-0 right-0 p-2 text-center text-xl text-yellow-300 pointer-events-none" style="text-shadow: 2px 2px #000; z-index: 10;">
                    PUNTOS: <span id="currentInGameScore">0</span>
                    <div class="flex justify-center items-center mt-1">
                        <div id="livesDisplay" class="text-red-500 text-lg mr-4">
                            </div>
                        <div id="inGamePowerUpDisplay" class="text-base text-pink-400 font-bold" style="font-size: 10px;">
                            </div>
                    </div>
                </div>
                
                <canvas id="gameCanvas" width="400" height="300"></canvas>
            
                <div id="levelTransitionScreen" class="absolute inset-0 flex flex-col items-center justify-center p-4 bg-black bg-opacity-80 hidden">
                    <h2 id="transitionMessage" class="text-4xl text-green-500 mb-6" style="text-shadow: 2px 2px #000;">NIVEL SUPERADO</h2>
                    <button id="nextLevelButton" class="retro-button text-xl hidden">CONTINUAR AL NIVEL <span id="nextLevelNumber"></span></button>
                </div>

                <div id="gameOverScreen" class="absolute inset-0 flex flex-col items-center justify-center p-4 bg-black bg-opacity-75 hidden">
                    <h2 class="text-4xl text-red-500 mb-4" style="text-shadow: 2px 2px #000;">GAME OVER</h2>
                    <button id="startButton" class="retro-button text-lg">REINTENTAR</button>
                </div>
            
                <div id="startScreen" class="absolute inset-0 flex flex-col items-center justify-center p-4 bg-black bg-opacity-75 hidden">
                    <p class="text-lg mb-4">Usa &larr; y &rarr; (o desliza el dedo) para moverte.</p>
                    <p class="text-lg mb-4 text-red-400">¬°Tienes <span id="initialLivesDisplay">3</span> vidas!</p>
                    <button id="initialStartButton" class="retro-button text-xl">EMPEZAR</button>
                </div>
            </div>
            
            <div id="statsPanel" class="mt-4 p-3 bg-gray-800 border-4 border-yellow-500 rounded-lg text-sm grid grid-cols-2 gap-2 w-full" style="font-family: 'Press Start 2P', monospace; max-width: 400px;">
                <div class="text-left">USUARIO: <span id="userDisplay" class="text-green-400">...</span></div>
                <div class="text-right">NIVEL: <span id="levelDisplay" class="text-pink-400">1</span></div>
                <div class="col-span-2 text-center text-yellow-400">MI R√âCORD: <span id="highScoreDisplay" class="text-pink-400">0</span></div>
            </div>

            <div class="mt-4 flex justify-center space-x-4 w-full" style="max-width: 400px;">
                <button id="showInfoButton" class="retro-button bg-blue-500 border-blue-700 hover:bg-blue-700 text-sm">GU√çA</button>
                <button id="showLeaderboardButton" class="retro-button bg-purple-500 border-purple-700 hover:bg-purple-700 text-sm">R√âCORDS</button>
                <button id="logoutButton" class="retro-button bg-gray-600 border-gray-700 hover:bg-gray-700 text-sm">CERRAR SESI√ìN</button>
            </div>
        </div>
    </div>

    <script type="module">
        // === CONFIGURACI√ìN GLOBAL DE FIREBASE ===
        const firebaseConfig = {
            apiKey: "AIzaSyDvAkI_aBIiezkbSEwgdmpduaGKtw4XLOs",
            authDomain: "controlceo-fdd05.firebaseapp.com",
            projectId: "controlceo-fdd05",
            storageBucket: "controlceo-fdd05.firebasestorage.app",
            messagingSenderId: "207151362101",
            appId: "1:207151362101:web:3ba86ac5680fd41e55417c"
        };
        const appId = firebaseConfig.projectId;

        // === FIREBASE IMPORTS ===
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged, updateProfile, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, collection, query, limit, onSnapshot, orderBy } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        // === INICIALIZACI√ìN DE FIREBASE ===
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        
        // Referencias a colecciones y documentos
        const getUserDocRef = (userId) => doc(db, `artifacts/${appId}/users/${userId}/data`, "game_stats");
        // Colecci√≥n p√∫blica para el Leaderboard
        const LEADERBOARD_COLLECTION = `artifacts/${appId}/public/data/leaderboard`;
        
        // === CONFIGURACI√ìN DEL JUEGO ===
        const CANVAS_WIDTH = 400;
        const CANVAS_HEIGHT = 300;
        const PLAYER_SIZE = 30;
        const OBJECT_SIZE = 25;
        const PLAYER_INITIAL_LIVES = 3; 
        const PLAYER_MAX_LIVES = 6; 
        const INVULNERABILITY_DURATION = 5000; 
        const SHIELD_BONUS_LIFE = 1; 

        // NUEVAS CONSTANTES DE NIVEL
        const SCORE_TO_LEVEL_UP = 300; 
        const MAX_LEVEL = 10;
        const BASE_SPAWN_INTERVAL_MS = 1000;
        const BASE_GAME_SPEED = 1.5;
        const MAX_HEARTS_PER_LEVEL = 3; 
        // CORRECCI√ìN SOLICITADA: 15 segundos (15000ms) de retardo para el coraz√≥n
        const HEART_SPAWN_INTERVAL_MS = 15000; 

        // Elementos del DOM
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const highScoreDisplay = document.getElementById('highScoreDisplay');
        // const powerUpDisplay = document.getElementById('powerUpDisplay'); // Eliminado del HTML, pero la referencia se mantiene en el c√≥digo JS por si acaso se desea reutilizar su l√≥gica interna.
        const inGamePowerUpDisplay = document.getElementById('inGamePowerUpDisplay');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startButton = document.getElementById('startButton');
        const initialStartButton = document.getElementById('initialStartButton');
        const gameScreens = document.getElementById('gameScreens');
        const userDisplay = document.getElementById('userDisplay');
        const levelDisplay = document.getElementById('levelDisplay');
        const currentInGameScore = document.getElementById('currentInGameScore');
        const livesDisplay = document.getElementById('livesDisplay'); 
        const initialLivesDisplay = document.getElementById('initialLivesDisplay');
        
        const levelTransitionScreen = document.getElementById('levelTransitionScreen');
        const transitionMessage = document.getElementById('transitionMessage');
        const nextLevelButton = document.getElementById('nextLevelButton');
        const nextLevelNumber = document.getElementById('nextLevelNumber');
        
        // Elementos de autenticaci√≥n y perfil
        const authScreen = document.getElementById('authScreen');
        const emailInput = document.getElementById('emailInput');
        const passwordInput = document.getElementById('passwordInput');
        const loginButton = document.getElementById('loginButton');
        const registerButton = document.getElementById('registerButton');
        const anonymousLoginButton = document.getElementById('anonymousLoginButton');
        const logoutButton = document.getElementById('logoutButton');
        const authMessage = document.getElementById('authMessage');
        // Usuario Registrado / Invitado (UNIFICADO)
        const profileScreen = document.getElementById('profileScreen');
        const nameInput = document.getElementById('nameInput');
        const lastNameInput = document.getElementById('lastNameInput');
        const saveProfileButton = document.getElementById('saveProfileButton');
        const profileMessage = document.getElementById('profileMessage');


        // Modals
        const leaderboard = document.getElementById('leaderboard');
        const leaderboardContent = document.getElementById('leaderboardContent');
        const infoPanel = document.getElementById('infoPanel');
        const showInfoButton = document.getElementById('showInfoButton');
        const showLeaderboardButton = document.getElementById('showLeaderboardButton');
        const closeInfoButton = document.getElementById('closeInfoButton');
        const closeLeaderboardButton = document.getElementById('closeLeaderboardButton');


        // Configuraci√≥n inicial del Canvas
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
        ctx.imageSmoothingEnabled = false;

        // === ESTADO GLOBAL DEL JUEGO ===
        let score = 0;
        let highScore = 0;
        let isPlaying = false;
        let currentLevel = 1;
        let player;
        let fallingObjects = [];
        let keys = {};
        let lastSpawnTime = 0;
        let animationFrameId;
        let userId = null; 
        let userName = null;
        let scoreMultiplier = 1; 
        
        // Estado de Vidas y Power-Ups
        let playerLives = PLAYER_INITIAL_LIVES; 
        let heartsSpawnedThisLevel = 0; 
        let lastHeartSpawnTime = 0; // Se inicializar√° con el primer currentTime
        let activePowerUp = null;
        let powerUpEndTime = 0;
        const POWER_UP_DURATION = 5000;

        // Estado de control de flujo
        let isPausedByTransition = false; 

        // Estado para el control t√°ctil
        let touchX = null;
        
        // L√≥gica de Autenticaci√≥n y Leaderboard (funciones auxiliares)
        
        function setAuthMessage(message, isError = false) {
            authMessage.textContent = message;
            authMessage.className = `mt-3 text-sm ${isError ? 'text-red-400' : 'text-green-400'}`;
        }
        
        function setProfileMessage(message, isError = false, targetElement) {
            targetElement.textContent = message;
            targetElement.className = `mt-3 text-sm ${isError ? 'text-red-400' : 'text-green-400'}`;
        }

        async function loadUserHighScore() {
            if (!userId) return;
            try {
                const docRef = getUserDocRef(userId);
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const data = docSnap.data();
                    highScore = data.highScore || 0;
                } else {
                    await setDoc(docRef, { highScore: 0 });
                    highScore = 0;
                }
                playerLives = PLAYER_INITIAL_LIVES; 
                updateHighScore(highScore);
            } catch (error) {
                console.error("Error al cargar el High Score:", error);
            }
        }
        
        async function saveUserStats() {
             if (!userId) return;
             try {
                 const docRef = getUserDocRef(userId);
                 const data = { 
                     highScore: highScore,
                 };
                 await setDoc(docRef, data, { merge: true });
             } catch (error) {
                 console.error("Error al guardar High Score personal:", error);
             }
        }

        function loadUserName() {
            const user = auth.currentUser;
            if (user) {
                if (user.displayName) {
                    userName = user.displayName;
                } else {
                    return false; // Forzar a ir a profileScreen si no hay display name
                }
                
                // Mostrar el display name, a√±adiendo "Invitado" si es an√≥nimo.
                const userPrefix = user.isAnonymous ? 'Invitado/' : '';
                userDisplay.textContent = userPrefix + userName;
                return true;
            }
            return false;
        }
        
        async function savePublicRecord(score) {
            // Se asegura que se utilice el √∫ltimo 'userName' cargado.
            if (!userId || !userName || score <= 0) {
                 return;
            }
            try {
                const docRef = doc(db, LEADERBOARD_COLLECTION, userId);
                const docSnap = await getDoc(docRef);
                const currentPublicScore = docSnap.exists() ? docSnap.data().score : 0;

                if (score > currentPublicScore) {
                    await setDoc(docRef, {
                        userId: userId,
                        userName: userName, // Usa el userName que se configur√≥ en loadUserName/saveProfileButton
                        score: score,
                        timestamp: Date.now()
                    }, { merge: true });
                }
            } catch (error) {
                console.error("Error al guardar r√©cord p√∫blico:", error);
            }
        }
        
        // Leaderboard listener (actualiza en tiempo real)
        const q = query(collection(db, LEADERBOARD_COLLECTION), orderBy("score", "desc"), limit(10));
        onSnapshot(q, (snapshot) => {
            const records = [];
            snapshot.forEach((doc) => {
                records.push(doc.data());
            });
            renderLeaderboard(records); 
        }, (error) => {
            console.error("Error al escuchar el Leaderboard:", error);
            leaderboardContent.innerHTML = '<p class="text-center text-xs text-red-400">Error al cargar la clasificaci√≥n.</p>';
        });
        
        function renderLeaderboard(records) {
            leaderboardContent.innerHTML = '';

            if (records.length === 0) {
                 leaderboardContent.innerHTML = '<p class="text-center text-xs">S√© el primero en el Leaderboard!</p>';
                 return;
            }
            
            records.forEach((record, index) => {
                const isCurrentUser = record.userId === userId;
                const item = document.createElement('div');
                item.className = 'flex justify-between items-center py-1 border-b border-gray-700 last:border-b-0';
                
                const name = record.userName.length > 20 ? record.userName.substring(0, 19) + '...' : record.userName;

                const nameClass = isCurrentUser ? 'text-pink-400 font-bold' : '';

                item.innerHTML = `
                    <span class="${nameClass}">${index + 1}. ${name}</span>
                    <span class="${nameClass}">${record.score}</span>
                `;
                leaderboardContent.appendChild(item);
            });
        }
        
        // Manejadores de Eventos de Auth
        loginButton.addEventListener('click', async () => {
            const email = emailInput.value;
            const password = passwordInput.value;
            if (!email || !password) {
                setAuthMessage("Ingresa email y contrase√±a.", true);
                return;
            }
            setAuthMessage("Iniciando sesi√≥n...");
            try {
                await signInWithEmailAndPassword(auth, email, password);
                setAuthMessage("");
            } catch (error) {
                setAuthMessage("Error de sesi√≥n: " + (error.message.includes('user-not-found') ? 'Usuario no encontrado' : 'Credenciales inv√°lidas'), true);
            }
        });
        
        registerButton.addEventListener('click', async () => {
            const email = emailInput.value;
            const password = passwordInput.value;
            if (password.length < 6) {
                setAuthMessage("La contrase√±a debe tener al menos 6 caracteres.", true);
                return;
            }
            setAuthMessage("Registrando usuario...");
            try {
                await createUserWithEmailAndPassword(auth, email, password);
            } catch (error) {
                setAuthMessage("Error de registro: " + (error.message.includes('email-already-in-use') ? 'El email ya est√° registrado' : 'Error desconocido'), true);
            }
        });
        
        anonymousLoginButton.addEventListener('click', async () => {
            setAuthMessage("Iniciando sesi√≥n como invitado...");
            try {
                await signInAnonymously(auth); 
            } catch (error) {
                setAuthMessage("Error al iniciar como invitado. Verifica que la autenticaci√≥n an√≥nima est√© habilitada.", true);
            }
        });
        
        saveProfileButton.addEventListener('click', async () => { 
             const name = nameInput.value.trim();
             const lastName = lastNameInput.value.trim();
             // Permitir solo el nombre si el apellido est√° vac√≠o
             const displayName = (name + (lastName ? " " + lastName : "")).trim(); 
            
             if (displayName.length < 3) {
                 setProfileMessage("Por favor, ingresa tu nombre de jugador (m√≠nimo 3 caracteres).", true, profileMessage);
                 return;
             }

             try {
                 const user = auth.currentUser;
                 
                 await updateProfile(user, { displayName: displayName });
                
                 // Recargar el nombre despu√©s de guardar
                 loadUserName(); 

                 profileScreen.classList.add('hidden');
                 gameScreens.classList.remove('hidden');
                 startScreen.classList.remove('hidden');
                
             } catch (error) {
                 setProfileMessage("Error al guardar perfil. Intenta de nuevo.", true, profileMessage);
             }
        });
        
        // Funci√≥n de cierre de sesi√≥n
        logoutButton.addEventListener('click', async () => {
            try {
                await signOut(auth);
            } catch (error) {
                console.error("Error al cerrar sesi√≥n:", error);
            }
        });
        
        // Listener de estado de autenticaci√≥n (CR√çTICO)
        onAuthStateChanged(auth, (user) => {
            loadingScreen.classList.add('hidden');
            infoPanel.classList.add('hidden');
            leaderboard.classList.add('hidden');
            
            if (user) {
                userId = user.uid;
                authScreen.classList.add('hidden');
                
                // Carga el high score y resetea las vidas a 3
                loadUserHighScore().then(() => {
                    // Si ya tiene nombre de display
                    if (loadUserName()) { 
                        profileScreen.classList.add('hidden');
                        gameScreens.classList.remove('hidden');
                        startScreen.classList.remove('hidden');
                        initialLivesDisplay.textContent = PLAYER_INITIAL_LIVES; 
                        setAuthMessage("");
                    } else {
                        // Si no tiene nombre (an√≥nimo o registrado), va a profileScreen
                        profileScreen.classList.remove('hidden');
                        gameScreens.classList.add('hidden');
                    }
                });

            } else {
                // Usuario desconectado
                gameScreens.classList.add('hidden');
                profileScreen.classList.add('hidden');
                authScreen.classList.remove('hidden');
                userId = null;
                userName = null;
                highScore = 0;
                playerLives = PLAYER_INITIAL_LIVES; // Resetear vidas
                initialLivesDisplay.textContent = playerLives;
                updateHighScore(0);
                setAuthMessage("Por favor, inicia sesi√≥n o juega como invitado.", true);
            }
        });
        
        // === CONFIGURACI√ìN DE AUDIO (TONE.JS) ===
        const synth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "square" }, envelope: { release: 0.1 } }).toDestination();
        const noise = new Tone.NoiseSynth({ noise: { type: "white" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.05 } }).toDestination();
        const metal = new Tone.MetalSynth().toDestination();

        function playCollectSound() { synth.triggerAttackRelease(["C5", "G5"], "16n"); }
        function playHitSound() { noise.triggerAttackRelease("8n", Tone.now(), 0.5); metal.triggerAttackRelease("4n", Tone.now() + 0.1, 0.5); }
        function playPowerUpSound() { synth.triggerAttackRelease(["C6", "E6", "G6", "C7"], "16n"); }
        function playShieldBlockSound() { synth.triggerAttackRelease(["D3", "A3"], "8n", Tone.now(), 0.8); }
        function playGameOverSound() { synth.triggerAttackRelease(["C3", "G#2", "F2"], "2n"); noise.triggerAttackRelease("2n", Tone.now(), 1.0); }


        // === IMPLEMENTACI√ìN DE POWER-UPS ===
        const powerUps = {
            'vacuum': {
                symbol: 'üåÄ',
                color: '#3498db',
                name: 'ASPIRADORA DE DONAS', 
                effect: () => { player.width = PLAYER_SIZE * 2; },
                cleanup: () => { player.width = PLAYER_SIZE; }
            },
            'shield': {
                symbol: 'üõ°Ô∏è',
                color: '#2ecc71',
                name: 'ESCUDO DE IMPACTO', 
                effect: () => { player.lives += SHIELD_BONUS_LIFE; }, 
                cleanup: () => { 
                    player.lives = playerLives; 
                } 
            },
            'slow': {
                symbol: 'üêå',
                color: '#f1c40f',
                name: 'TIEMPO LENTO', 
                effect: () => {}, 
                cleanup: () => {}
            },
            'x2': {
                symbol: '‚ö°',
                color: '#ffc107',
                name: 'PUNTOS DOBLES', 
                effect: () => { scoreMultiplier = 2; },
                cleanup: () => { scoreMultiplier = 1; }
            },
            'x3': {
                symbol: 'üåü',
                color: '#ff5722',
                name: 'PUNTOS TRIPLES', 
                effect: () => { scoreMultiplier = 3; },
                cleanup: () => { scoreMultiplier = 1; }
            },
            'totalImmunity': { // MODIFICADO: INMUNIDAD TOTAL
                symbol: '‚≠ê', 
                color: '#e67e22',
                name: 'INMUNIDAD TOTAL', 
                effect: () => {},
                cleanup: () => {}
            }
        };
        const objectSymbols = {
            'donut': 'üç©',
            'bomb': 'üí£',
            'stone': 'üß±',
            'heart': '‚ù§Ô∏è', 
        };
        
        // Funci√≥n para actualizar los corazones en el HTML
        function updateLivesDisplay() {
            const hasShield = activePowerUp === 'shield' && player.lives > playerLives;
            const extraIndicator = hasShield ? ' üõ°Ô∏è' : '';
            
            livesDisplay.innerHTML = '‚ù§Ô∏è '.repeat(playerLives) + extraIndicator;
        }

        // === CLASES DE ENTIDADES ===

        class Player {
            constructor(x, y, size, initialLives) {
                this.x = x;
                this.y = y;
                this.width = size;
                this.height = size;
                this.speed = 4;
                this.lives = initialLives; 
                this.isInvulnerable = false; 
                this.invulnerabilityEndTime = 0; 
            }

            draw() {
                // El efecto de parpadeo de invulnerabilidad (transparencia)
                if (this.isInvulnerable && Date.now() < this.invulnerabilityEndTime && Math.floor(Date.now() / 100) % 2 === 0) {
                    return; 
                }

                // Usar la fuente pixelada para el renderizado del canvas
                ctx.font = `${this.height}px 'Press Start 2P', monospace`;
                ctx.textAlign = 'center';
                const emoji = 'üõí';

                ctx.fillText(emoji, this.x + this.width / 2, this.y + this.height * 0.9);
                
                // Dibujar el efecto del escudo 
                if (this.lives > playerLives) {
                    ctx.fillStyle = 'rgba(46, 204, 113, 0.4)';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    ctx.fillStyle = '#2ecc71';
                    ctx.fillRect(this.x, this.y, this.width, 3);
                    ctx.fillRect(this.x, this.y + this.height - 3, this.width, 3);
                }
            }

            update() {
                // Control de movimiento 
                if (keys['ArrowLeft'] || keys['a']) {
                    this.x -= this.speed;
                }
                if (keys['ArrowRight'] || keys['d']) {
                    this.x += this.speed;
                }
                if (touchX !== null) {
                    const targetX = touchX - this.width / 2;
                    const dx = targetX - this.x;
                    if (Math.abs(dx) > this.speed) {
                        this.x += Math.sign(dx) * this.speed;
                    } else {
                        this.x = targetX;
                    }
                }

                if (this.isInvulnerable && Date.now() > this.invulnerabilityEndTime) {
                    this.isInvulnerable = false;
                }

                if (this.x < 0) this.x = 0;
                if (this.x + this.width > CANVAS_WIDTH) this.x = CANVAS_WIDTH - this.width;
            }
        }

        class FallingObject {
            constructor(x, y, type, speed) {
                this.x = x;
                this.y = y;
                this.width = OBJECT_SIZE;
                this.height = OBJECT_SIZE;
                this.type = type;
                this.speed = speed;
            }

            getSymbol() {
                if (powerUps[this.type]) {
                    return powerUps[this.type].symbol;
                }
                return objectSymbols[this.type] || '‚ùì';
            }

            draw() {
                // Usar la fuente pixelada para el renderizado del canvas
                ctx.font = `${this.height}px 'Press Start 2P', monospace`;
                ctx.textAlign = 'center';

                if (powerUps[this.type]) {
                    ctx.fillStyle = powerUps[this.type].color;
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
                // Dibuja un aura para los corazones
                if (this.type === 'heart') {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }

                ctx.fillText(this.getSymbol(), this.x + this.width / 2, this.y + this.height * 0.9);
            }

            update() {
                let currentSpeed = this.speed;
                // L√ìGICA DE LENTITUD
                if (activePowerUp === 'slow' && Date.now() < powerUpEndTime) {
                    currentSpeed *= 0.5; 
                }

                this.y += currentSpeed;
                if (activePowerUp === 'vacuum' && Date.now() < powerUpEndTime && this.type === 'donut') {
                    const playerCenterX = player.x + player.width / 2;
                    const objectCenterX = this.x + this.width / 2;
                    const diffX = playerCenterX - objectCenterX;

                    this.x += Math.sign(diffX) * 2;
                }
            }
        }

        // === L√ìGICA DEL JUEGO ===

        function getDifficultyMultiplier(level) {
            return 1 + (level - 1) * 0.15;
        }

        function startNewLevel(level) {
            if (!userId || !userName) {
                // Forzar la creaci√≥n de nombre si a√∫n no lo tiene
                profileScreen.classList.remove('hidden');
                gameScreens.classList.add('hidden');
                return;
            }
            if (Tone.context.state !== 'running') {
                Tone.start();
            }

            currentLevel = level;
            levelDisplay.textContent = currentLevel;
            
            // CORRECCI√ìN SOLICITADA: Score solo se reinicia en Nivel 1 (inicio de partida)
            if (level === 1) { 
                score = 0;
                playerLives = PLAYER_INITIAL_LIVES; 
                updateHighScore(highScore);
            }
            
            isPlaying = true;
            
            // Reinicia jugador, objetos y estado
            // Nota: player.lives siempre se ajusta a playerLives (la vida actual del juego)
            player = new Player(CANVAS_WIDTH / 2 - PLAYER_SIZE / 2, CANVAS_HEIGHT - PLAYER_SIZE - 10, PLAYER_SIZE, playerLives); 
            fallingObjects = [];
            lastSpawnTime = 0;
            
            // Resetear contadores de nivel
            heartsSpawnedThisLevel = 0;
            // ************ CORRECCI√ìN CR√çTICA DE SINCRONIZACI√ìN ************
            // Se inicializa a 0. El gameLoop lo establecer√° en el primer currentTime de rAF.
            lastHeartSpawnTime = 0; 
            // **************************************************************
            
            // Limpiar Power-Up si exist√≠a
            if (activePowerUp) {
                powerUps[activePowerUp].cleanup();
            }
            activePowerUp = null;
            powerUpEndTime = 0;
            scoreMultiplier = 1; 
            player.isInvulnerable = false;
            touchX = null;
            
            // Limpiar Power-Up Display
            inGamePowerUpDisplay.textContent = ''; 
            // powerUpDisplay.textContent = 'NINGUNO'; // Eliminado
            
            // Actualizar display de vidas y multiplicador
            updateLivesDisplay();
            document.getElementById('guideMultiplier').textContent = scoreMultiplier;
            initialLivesDisplay.textContent = playerLives;
            
            // Oculta pantallas de men√∫
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            levelTransitionScreen.classList.add('hidden');
            
            document.getElementById('statsPanel').classList.remove('hidden');
            
            // Muestra el n√∫mero de nivel brevemente y PAUSA EL JUEGO
            if (level > 1) {
                isPausedByTransition = true; 
                transitionMessage.textContent = `NIVEL ${level}`;
                nextLevelButton.classList.add('hidden');
                levelTransitionScreen.classList.remove('hidden');
                setTimeout(() => {
                    levelTransitionScreen.classList.add('hidden');
                    isPausedByTransition = false; 
                }, 1500);
            } else {
                 isPausedByTransition = false; 
            }

            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            gameLoop(0);
        }

        function initGame() {
            startNewLevel(1);
        }

        function levelUp() {
            isPlaying = false;
            cancelAnimationFrame(animationFrameId);
            
            // Limpiar power-up activo
            if (activePowerUp) {
                powerUps[activePowerUp].cleanup();
                activePowerUp = null;
                // powerUpDisplay.textContent = 'NINGUNO'; // Eliminado
                inGamePowerUpDisplay.textContent = ''; 
            }
            scoreMultiplier = 1; 

            if (currentLevel >= MAX_LEVEL) {
                transitionMessage.textContent = '¬°JUEGO COMPLETADO! (NIVEL M√ÅXIMO)';
                nextLevelButton.textContent = 'VOLVER A EMPEZAR (NIVEL 1)';
                nextLevelButton.onclick = () => startNewLevel(1);
                
                if (score > highScore) {
                    updateHighScore(score);
                    saveUserStats(); 
                }
                
                savePublicRecord(score); // Guardar r√©cord p√∫blico

                
            } else {
                currentLevel++;
                transitionMessage.textContent = 'NIVEL SUPERADO';
                nextLevelNumber.textContent = currentLevel;
                nextLevelButton.textContent = `CONTINUAR AL NIVEL ${currentLevel}`;
                nextLevelButton.onclick = () => startNewLevel(currentLevel);
            }
            
            levelTransitionScreen.classList.remove('hidden');
            nextLevelButton.classList.remove('hidden');
        }


        function updateHighScore(newScore) {
            if (newScore > highScore) {
                highScore = newScore;
            }
            highScoreDisplay.textContent = highScore;
        }

        function spawnObject(currentTime) {
            const levelDifficulty = getDifficultyMultiplier(currentLevel);
            const timeElapsed = currentTime - lastSpawnTime;
            const scoreMultiplierForDifficulty = 1 + Math.floor(score / 150) * 0.1;
            
            const spawnInterval = BASE_SPAWN_INTERVAL_MS / (levelDifficulty * scoreMultiplierForDifficulty); 
            
            // L√≥gica de spawn de Coraz√≥n (intervalo y l√≠mite)
            if (playerLives < PLAYER_MAX_LIVES && heartsSpawnedThisLevel < MAX_HEARTS_PER_LEVEL && currentTime - lastHeartSpawnTime > HEART_SPAWN_INTERVAL_MS) {
                const x = Math.random() * (CANVAS_WIDTH - OBJECT_SIZE);
                const speed = BASE_GAME_SPEED * levelDifficulty * scoreMultiplierForDifficulty * 0.9;
                
                fallingObjects.push(new FallingObject(x, -OBJECT_SIZE, 'heart', speed));
                heartsSpawnedThisLevel++;
                lastHeartSpawnTime = currentTime; // Actualiza el tiempo con el valor de rAF
                return; 
            }


            if (timeElapsed > spawnInterval) {
                lastSpawnTime = currentTime;
                const x = Math.random() * (CANVAS_WIDTH - OBJECT_SIZE);
                const speed = BASE_GAME_SPEED * levelDifficulty * scoreMultiplierForDifficulty * 0.9; 

                let objectType = 'donut';
                const rand = Math.random();

                // L√≥gica de Power-Ups (excluyendo Coraz√≥n)
                let powerUpChance = currentLevel >= 2 ? 0.15 : 0.08; 
                
                if (score > 100) {
                    // Power-Ups comunes
                    if (rand < powerUpChance) { 
                        const availablePowerUps = ['vacuum', 'shield', 'slow'];
                        
                        if (currentLevel >= 2) {
                            availablePowerUps.push('x2', 'x3');
                        }
                        if (currentLevel >= 3) {
                            availablePowerUps.push('totalImmunity'); // MODIFICADO: Cambiado a 'totalImmunity'
                        }
                        
                        objectType = availablePowerUps[Math.floor(Math.random() * availablePowerUps.length)];
                    } 
                    // Peligros
                    else if (rand < 0.2 + (score / 2000)) {
                        if (Math.random() < 0.5) {
                            objectType = 'bomb';
                        } else {
                            objectType = 'stone';
                        }
                    }
                }

                fallingObjects.push(new FallingObject(x, -OBJECT_SIZE, objectType, speed));
            }
        }

        function checkCollisions(object, index) {
            // Colisi√≥n con el jugador
            if (
                object.x < player.x + player.width &&
                object.x + object.width > player.x &&
                object.y < player.y + player.height &&
                object.y + object.height > player.y
            ) {
                handleHit(object, index);
                return true;
            }

            // Objeto fuera de la pantalla (p√©rdida)
            if (object.y > CANVAS_HEIGHT) {
                // Si es una dona y se pierde
                if (object.type === 'donut') {
                    
                    // L√ìGICA DE INMUNIDAD TOTAL (No pierde vida por dona ca√≠da)
                    if (activePowerUp === 'totalImmunity' && Date.now() < powerUpEndTime) {
                        fallingObjects.splice(index, 1); 
                        return true; 
                    }
                    
                    if (player.isInvulnerable) {
                        fallingObjects.splice(index, 1); 
                        return true;
                    }

                    player.lives--;
                    playerLives = Math.max(0, playerLives - 1); 
                    updateLivesDisplay();
                    playHitSound();
                    
                    if (player.lives <= 0) {
                         gameOver();
                    } else {
                        player.isInvulnerable = true;
                        player.invulnerabilityEndTime = Date.now() + INVULNERABILITY_DURATION; 
                        player.x = CANVAS_WIDTH / 2 - player.width / 2; 
                        
                        if (activePowerUp === 'shield') {
                            powerUps['shield'].cleanup(); 
                            activePowerUp = null;
                            // powerUpDisplay.textContent = 'NINGUNO'; // Eliminado
                            inGamePowerUpDisplay.textContent = ''; 
                        }
                    }
                    fallingObjects.splice(index, 1);
                    return true;
                }
                
                fallingObjects.splice(index, 1);
                return true;
            }

            return false;
        }

        function handleHit(object, index) {
            fallingObjects.splice(index, 1);
            if (object.type === 'donut') {
                score += 10 * scoreMultiplier; 
                updateHighScore(score);
                playCollectSound();
            } else if (object.type === 'heart') {
                // Evitar que el coraz√≥n active la invulnerabilidad al recogerlo.
                if (playerLives < PLAYER_MAX_LIVES) {
                    playerLives++; 
                    player.lives = playerLives; 
                    
                    if(activePowerUp === 'shield') {
                        player.lives += SHIELD_BONUS_LIFE;
                    }

                    updateLivesDisplay();
                    playPowerUpSound();
                } else {
                    // Si ya tiene max vidas, da puntos de bonificaci√≥n
                    score += 20 * scoreMultiplier;
                    updateHighScore(score);
                    playCollectSound(); 
                }
            } else if (object.type === 'bomb' || object.type === 'stone') {
                
                // L√ìGICA DE INMUNIDAD TOTAL (No pierde vida por golpe)
                if (activePowerUp === 'totalImmunity' && Date.now() < powerUpEndTime) {
                    playPowerUpSound(); // Sonido de absorci√≥n
                    // Peque√±o efecto visual para confirmar el bloque
                    canvas.style.borderColor = powerUps['totalImmunity'].color; 
                    setTimeout(() => canvas.style.borderColor = '#f4d03f', 150); 
                    return; 
                }
                
                if (player.isInvulnerable) {
                    return; 
                }
                
                if (activePowerUp === 'shield' && player.lives > playerLives) {
                    
                    powerUps['shield'].cleanup();
                    activePowerUp = null;
                    powerUpEndTime = 0;
                    
                    playShieldBlockSound();
                    canvas.style.borderColor = '#3498db';
                    setTimeout(() => canvas.style.borderColor = '#f4d03f', 200);
                    
                    // powerUpDisplay.textContent = 'NINGUNO'; // Eliminado
                    inGamePowerUpDisplay.textContent = ''; 
                    updateLivesDisplay(); 
                } else {
                    player.lives--;
                    playerLives = Math.max(0, playerLives - 1); 
                    playHitSound();
                    updateLivesDisplay(); 

                    if (player.lives <= 0) {
                        gameOver();
                    } else {
                        // Solo activar invulnerabilidad al perder vida por golpe de peligro
                        player.isInvulnerable = true;
                        player.invulnerabilityEndTime = Date.now() + INVULNERABILITY_DURATION; 
                        player.x = CANVAS_WIDTH / 2 - player.width / 2; 
                    }
                }
            } else if (powerUps[object.type]) {
                activatePowerUp(object.type);
            }
        }

        function activatePowerUp(type) {
            if (activePowerUp && activePowerUp !== type) {
                powerUps[activePowerUp].cleanup();
            }

            activePowerUp = type;
            powerUpEndTime = Date.now() + POWER_UP_DURATION;
            powerUps[activePowerUp].effect();
            
            const puName = powerUps[activePowerUp].name;
            // powerUpDisplay.textContent = puName; // Eliminado
            inGamePowerUpDisplay.textContent = puName; 

            canvas.style.boxShadow = `0 0 30px 10px ${powerUps[activePowerUp].color}, inset 0 0 15px rgba(255, 255, 255, 0.7)`;
            playPowerUpSound();
            
            document.getElementById('guideMultiplier').textContent = scoreMultiplier;
            updateLivesDisplay(); 
        }

        function checkPowerUpExpiry() {
            if (activePowerUp && Date.now() > powerUpEndTime) {
                powerUps[activePowerUp].cleanup();
                activePowerUp = null;
                
                // LIMPIAR DISPLAY
                // powerUpDisplay.textContent = 'NINGUNO'; // Eliminado
                inGamePowerUpDisplay.textContent = '';

                canvas.style.boxShadow = '0 0 20px rgba(244, 208, 63, 0.7), inset 0 0 10px rgba(255, 255, 255, 0.5)';
                
                scoreMultiplier = 1;
                document.getElementById('guideMultiplier').textContent = scoreMultiplier;
                updateLivesDisplay(); 
            }
        }

        function gameOver() {
            isPlaying = false;
            cancelAnimationFrame(animationFrameId);

            playGameOverSound();

            if (score > highScore) {
                updateHighScore(score);
            }
            // Guardar high score
            saveUserStats();

            // Guardar r√©cord p√∫blico para todos los jugadores con nombre
            savePublicRecord(score);

            gameOverScreen.classList.remove('hidden');
            if (activePowerUp) {
                powerUps[activePowerUp].cleanup();
                activePowerUp = null;
            }
            
            // LIMPIAR DISPLAY
            // powerUpDisplay.textContent = 'NINGUNO'; // Eliminado
            inGamePowerUpDisplay.textContent = '';
            
            scoreMultiplier = 1; 
            document.getElementById('guideMultiplier').textContent = scoreMultiplier;

            canvas.style.borderColor = '#f4d03f';
            canvas.style.boxShadow = '0 0 20px rgba(244, 208, 63, 0.7), inset 0 0 10px rgba(255, 255, 255, 0.5)';
        }

        function drawGame() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Se usa la fuente retro en los m√©todos draw de Player y FallingObject
            for (let i = 0; i < fallingObjects.length; i++) {
                fallingObjects[i].draw();
            }

            player.draw();

            currentInGameScore.textContent = score;

            highScoreDisplay.textContent = highScore;
            levelDisplay.textContent = currentLevel;

            if (activePowerUp && Date.now() < powerUpEndTime) {
                const elapsed = Date.now() - (powerUpEndTime - POWER_UP_DURATION);
                const percentage = 1 - (elapsed / POWER_UP_DURATION);
                const barWidth = CANVAS_WIDTH * percentage;

                ctx.fillStyle = powerUps[activePowerUp].color;
                ctx.fillRect(0, 0, barWidth, 5);
            }
        }

        // === BUCLE PRINCIPAL DEL JUEGO ===

        function gameLoop(currentTime) {
            if (!isPlaying) return;
            
            // ************ CORRECCI√ìN DE SINCRONIZACI√ìN ************
            // Si es la primera ejecuci√≥n despu√©s de un startNewLevel, sincroniza el tiempo del coraz√≥n.
            if (lastHeartSpawnTime === 0) {
                lastHeartSpawnTime = currentTime;
            }
            // ******************************************************
            
            // Chequeo de Nivel 
            if (currentLevel < MAX_LEVEL && score >= currentLevel * SCORE_TO_LEVEL_UP) {
                levelUp();
                return;
            }
            
            player.update();
            
            // VERIFICACI√ìN DE PAUSA
            if (!isPausedByTransition) {
                spawnObject(currentTime);
                checkPowerUpExpiry();

                for (let i = fallingObjects.length - 1; i >= 0; i--) {
                    fallingObjects[i].update();
                    checkCollisions(fallingObjects[i], i);
                }
            } else {
                 checkPowerUpExpiry();
            }


            drawGame();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // === EVENTOS DEL JUEGO (TECLADO Y T√ÅCTIL) ===

        initialStartButton.addEventListener('click', initGame);
        startButton.addEventListener('click', initGame);
        nextLevelButton.addEventListener('click', () => startNewLevel(currentLevel));

        // Control por teclado
        document.addEventListener('keydown', (e) => {
            if (!isPlaying && (e.key === 'Enter' || e.key === ' ') && (startScreen.classList.contains('hidden') === false || gameOverScreen.classList.contains('hidden') === false || levelTransitionScreen.classList.contains('hidden') === false)) {
                
                if(!levelTransitionScreen.classList.contains('hidden')) {
                    nextLevelButton.click();
                } else {
                    initGame();
                }
                return;
            }

            if (isPlaying) {
                keys[e.key] = true;
            }
        });
        document.addEventListener('keyup', (e) => {
            if (isPlaying) {
                keys[e.key] = false;
            }
        });
        
        // --- Control T√°ctil --- 
        function getTouchX(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.touches[0].clientX - rect.left;
            return (x / rect.width) * CANVAS_WIDTH;
        }

        canvas.addEventListener('touchstart', (e) => {
            if (isPlaying) {
                touchX = getTouchX(e);
            }
        });
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); 
            if (isPlaying) {
                touchX = getTouchX(e);
            }
        });
        canvas.addEventListener('touchend', () => {
            // touchX se mantiene
        });
        
        // === EVENTOS DE UTILIDAD (Gu√≠a y Leaderboard) ===
        
        showInfoButton.addEventListener('click', () => {
             infoPanel.classList.toggle('hidden');
             leaderboard.classList.add('hidden');
        });
        
        closeInfoButton.addEventListener('click', () => {
             infoPanel.classList.add('hidden');
        });

        showLeaderboardButton.addEventListener('click', () => {
             leaderboard.classList.toggle('hidden');
             infoPanel.classList.add('hidden');
        });
        
        closeLeaderboardButton.addEventListener('click', () => {
             leaderboard.classList.add('hidden');
        });

    </script>
</body>
</html>